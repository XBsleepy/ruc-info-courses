## 01 两数之和 twoSum

### 题目

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

### 暴力解法

要找A+B=Target。

很容易想到的是两个for循环直接遍历，在本题的要求下能解决。

```c++
vector<int> twoSum(vector<int> &nums, int target)//暴力解法
{
      vector<int> answer;
    for(int i = 0; i < nums.size(); i++)
    {
        for(int j = i+1; j < nums.size(); j++)//这里从i+1开始，不然如果遇到nums[i]==target/2,会出错。
        {
            if(nums[i] + nums[j] == target)
            {
                answer.push_back(i);
                answer.push_back(j);
                return answer;
            }
        }
    }
    return answer;
}
```



### 优化版

A+B=Target，那么只要Target-B在nums中即可。

可以把nums数组中的值存在set中，直接查询是否在其中，能够实现优化。

但这里要注意由于用的是set，会去掉重复数字，遇到target/2时需要单独判断一下，否则由于set中存在target/2，就会出错。

最后如果无法找到对应答案，就证明有两个数等于target/2，单独跑一下。

```C++
vector<int> twoSum(vector<int> &nums, int target)//哈希表解法
{
    unordered_set<int> set1;
    for (auto &x : nums)
    {
        set1.insert(x);
    }
    int temp = 0;
    int len=nums.size();
    vector<int> answer;
    for (int i = 0; i < len; i++)
    {
        if (set1.find(target - nums[i]) != set1.end()&&nums[i]!=target-nums[i])
        {
            answer.push_back(i);
            temp = nums[i];
            while (1)
            {
                i++;
                if (nums[i] == target - temp)
                {
                    answer.push_back(i);
                    break;
                }
            }
            break;
        }
    }
            if(answer.empty()){
            for(int i=0;i<len;i++){
                if(nums[i]==target/2){
                    answer.push_back(i);
                }
            }
        }
    return answer;
```

### leetcode官方题解

相当于在优化版的基础上更进一步，不用set而是使用map，这能够省去已知num[i]+num[j]=target,寻找j下标的时间。

同时通过先判断map中是否有target-nums[i]再将之加入map，能够免去对target/2的特判。

```cpp
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
```

### 其他解法

在剑指offer中有一个类似题目，但题目所给的是单调数组。可以借鉴其中一个美妙思路，先将给出的数组进行排序，然后再利用其中的方法来解决:

> 1. 可以空间换时间。
>
>    把扫描到的数字存在哈希表里，查表的复杂度低，这样的话就o（n）了
>
> 2. 可以用两个指针来记录和，一个p1指向第一个，一个p2指向最后一个。
>
>    如果两个指到的和为k，就过了。
>
>    不然的话，p1可以向右移，和会增大；p2可以向左移动，和会减小。
>
>    只要有解，不断移动，就能达到那个解。
>
>    只遍历一遍数组，且空间复杂度为1，所以非常牛逼。
>    
> 3. re：这样对重复数组可能无法处理？

## 02 字母异位词分组 groupAnagrams

### 题目

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

### 思路

考虑相同字母构成的字符串的共同特性：

1. 将每个字符串排序之后能够得到相同字符串。
2. 每个字母出现的次数相同。

### 排序哈希表

直接对每个字符串进行进行排序，可以将排序后的结果作为key，原字符串作为value存起来。

最后把每个key对应的value vector放到answer vector中输出即可。

``` cpp
vector<vector<string>> groupAnagrams(vector<string>& strs) {//排序哈希表解法
        unordered_map<string,vector<string>> mp;
        for(auto& str:strs){
            string key=str;
            sort(key.begin(),key.end());
            mp[key].emplace_back(str);
        }
        vector<vector<string>> ans;
        for(auto& [key,value]:mp){
            ans.emplace_back(value);
        }
        return ans;
    }
```

### 计数哈希表解法

用一个长度26的数组来存每个字母出现的次数，再把出现次数排成一个新的字符串来作为键。

```cpp
vector<vector<string>> groupAnagrams(vector<string>& strs){//计数哈希表解法
    vector<vector<string>> ans;
    unordered_map<string,vector<string>> mp;
    for(auto &substr:strs){
        int num_list[26]={0};
        for(auto &i:substr){
            num_list[i-'a']++;
        }
        string key;
        for(int i=0;i<26;i++){
        //这一段有一些值得注意的点
        //如果对某个位的计数大于10，那么会有问题：比如（假设是两位） 11 0 和 1 10.无法分辨，会出问题。
        //所以需要在前面加一个标记位：i+‘a’来区分这两种情况。
        //真是这样吗？可能是的，因为ascii与1-10并不是直接对应的，所以具体能不能构造出一个这个例子有待商榷，至少这样是能过的。
        //后面的+'0'其实也是可以不用的，这样对应的就不是数字对应的ascii，而是直接的ascii的1-10，可能会有问题？
            key+=i+'a';
            key+=string(1,num_list[i]+'0');
        }
        mp[key].emplace_back(substr);
    }
    for(auto& [key,value]:mp){
        ans.emplace_back(value);
    }
    return ans;
}
```

官方题解中用的是Array，或许避免了这个问题。

### 其他解法

自己想的时候想到了或许可以用一个26位的整数来表示，这样子在比较运算时可以更快。

但问题是：

1. 没有26位那么长（python可以解决）
2. 某位对应超过10次的话，会因为进位而导致错误。（相同字符串仍然对应相同值，但相同值可能对应不同字符串。）

在题解区看到的解法：

用26个不同质数来表示a->z，然后用乘积来表示数字，这样能保证一一对应。（类似于这个是基于乘法，自己想的是基于加法，但没找到一个适用于加法的基数。看了一下，测试点最大单个长度小于100，那么其实改成26*3位，每三个位表示一个数字就可以了，只是不知道大整数运算在python里和字符串相比谁更快，有空可以写一写。）

## 03 *最长连续子序列 longestConsecutive

### 题目

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

### 分析

如果不是限制在O（n)上，其实还是比较简单的，排序之后再判断最长串就可以了。

O（n）答案自己没想出来，确实很美妙。

但有一个问题：

set去重的复杂度如何考虑？是否会超过o(n)?这或许是官方题解跑不过排序的原因之一？

```cpp
    int longestConsecutive(vector<int>& nums) {
        set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
        }
        int longestStreak = 0;
        for (const int& num : num_set) {
            if (!num_set.count(num - 1)) {
                //这里通过判断num-1是否在，实现了对连续子串的直接判断。
                //如果num-1不在，就不会进入内部循环，总体上就相当于是一个o（n）了。
                int currentNum = num;
                int currentStreak = 1;
                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }
                longestStreak = max(longestStreak, currentStreak);
            }
        }
        return longestStreak;
    }

```

（这道题应该是测试点没弄好，所以排序nlogn的解法也能过，甚至比官方解快，有趣。

## 04 移动零 moveZeroes

### 题目

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

### 解答

可以通过一次遍历不超过两次遍历实现。

第一次是从头开始扫数组，把每个非0位向前移动k位，k为该位置之前的0的数量。

最后从length-k开始，把数组剩余的值全部赋值为0。

复杂度O（n)，但系数略大于1。

```cpp
void moveZeroes(vector<int>& nums) {
    int length=nums.size();
    int count=0;

    for(int i=0;i<length;i++){
        if(nums[i]!=0){
            nums[i-count]=nums[i];
        }
        else{
            count++;
        }
    }
    for(int i=length-count;i<length;i++){
        nums[i]=0;
    }
    }
```

官方解法是双指针，一个标志的是左边全部是处理好的，一个标志的是右边全部是未处理的，分别设置为左和右。

大概类似于，右指针扫描到非0，就交换左右指针对应的值。

官方版只用遍历一次，我的解法需要一次以上。官方会更快。

```cpp
//leetcode官方解法
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size(), left = 0, right = 0;
        while (right < n) {
            if (nums[right]) {
                swap(nums[left], nums[right]);
                left++;
            }
            right++;
        }
    }
};
```

## 05 盛水最多的容器 Container with most water

### 题目

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

### 解答

首先要明确水量的计算：
$$
Water=(Right-Left)\times shoter(Left,Right)
$$
其次，考虑使用双指针，每次将左右两边中较短的向中间移动。为什么？

不失一般性，考虑左边高低于右边高。

移动Left。

从初始情况考虑：

我们知道，移动之前，根据水量的计算公式，如果固定左边，因为左边是目前的短边，那么容器高度受到左边限制。当左边固定在该位置时，考虑右边的所有可能情况：

因为高度肯定小于等于左边。可知只有当右边位于最左端时，底边最长，此时起到限制作用的短边还是左边，这是在左边选择目前情况下所能拿到的最优解。

在移动过程中，相当于我们遍历了把任意一个位置当作短边的情况（终止条件是左等于右）。

由于每个位置都是当前位置最优解，所以最终结果是全局的最优解。

```cpp
int maxArea(vector<int>& height) {
        int left=0;
        int right=height.size()-1;//注意是len-1，不然就越界了。
        int max_area=0;
        while(left!=right){
            int temp=0;
            int shorter=min(height[left],height[right]);
            temp=(right-left)*shorter;
            height[left]>=height[right]?right--:left++; 
            max_area=max(max_area,temp);
        }
        return max_area;
    }

```

 

![image-20240111123514822](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20240111123514822.png)

## 06 三数之和 three sum

### 题目

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

### 解答分析

首先注意到答案中不能有重复的三元组，去重是一个很重要的点。

数据量小于3000。

首先考虑排序，排序是为了更好的遍历和去重。

1. 如果有相同数字，排序后出现位置挨在一起，方便跳过相同情况。
2. 遍历时从小到大，便于思考且有利于剪枝等操作。

排完序之后用双指针法解决：

遍历整个数组，i从0到len-2.

选定遍历元素num[i]，然后left=i+1，right=len-1；

left++，和变大，right--，和变小。

直到二者相遇，退出。

如果和为0，跳过相同元素，继续向内，看看是否还有解比如（-4,1,1,2,2,3,3),会有（-4，1，3）和（-4，2，2），不能直接和为0时就跳出。

这样就能解决。

```CPP
vector<vector<int>> threeSum(vector<int> &nums)
{
    vector<vector<int>> ans;
    if (nums.size() < 3)
        return ans;
    int len = nums.size();
    sort(nums.begin(), nums.end());
    for (int i = 0; i < len - 2; i++)
    {   //如果nums[i]已经大于0，那么由于数组递增，三数字之和必然大于0，所以直接返回。
        if (nums[i] > 0)
            break;
        if (i > 0 && nums[i] == nums[i - 1])//跳过相同的重复元素，i>0是为了防止越界，同时保证不会跳过第一个元素。
            continue;
        //这里参考了@灵茶山艾府 老师的优化。
        //如果当前元素和最后后两个元素的和都小于0，那么就不用再进行计算了。
        //因为后面的元素都是递增的，不可能再有符合条件的元素了。
        if (nums[i] + nums[len- 2] + nums[len - 1] < 0) 
        continue; 
    
        int left = i + 1;
        int right = len - 1;
        while (left < right)
        {
            int temp = nums[i] + nums[left] + nums[right];
            if (temp == 0)
            {
                vector<int> temp_ans = {nums[i], nums[left], nums[right]};
                ans.push_back(temp_ans);
                //对重复的元素进行处理
                while (left < right && nums[left] == nums[left + 1])
                    left++;
                while (left < right && nums[right] == nums[right - 1])
                    right--;
                left++;
                right--;
            }
            else if (temp < 0)
                left++;
            else
                right--;
        }
    }
    return ans;
```

但我最初的想法是，固定的不是第一个元素，是第二个，然后左右分别是i-1和i+1，这在判重上会出问题，暂时还没想明白如何解决。

## 07 接雨水 trapping rain water

### 题目

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

### 解答一 双指针

其实思路有点像**05 装水容器**。

对任意一个位置i，它所能装的水量是(min(height[left],height[right])-height[i])，其中，left和right分别是左右的比他高且最高的柱子。

从这里能联想到第五题。

所以我们使用双指针，只要知道每个i所能装的水，再求和，就可以了。

所以从最左端和最右端开始，用两个变量保存目前最高的左边和最高的右边。

然后依次短边向内移动，要么计算水量，要么更新最长边。由此，可以得到最终结果。

```CPP
int trap(vector<int>& height) {
        int ans = 0;
        int left = 0, right = height.size() - 1;
        int leftMax = 0, rightMax = 0;
        while(left<right){
            if(height[left]<height[right]){//左为短边，对左边进行操作
                if(height[left]<leftMax){//目前的地方可以接水
                    ans+=leftMax-height[left];//记得要用边界去减掉
                }
                else{//接不到水
                    leftMax=height[left];//如果出现新的最高，就更新边界值
                }
                left++;//左柱子移动。
            }
            else{//这边也同理
                if(height[right]<rightMax){
                    ans+=rightMax-height[right];
                }
                else{
                    rightMax=height[right];
                }
                right--;
            }
        }
return ans;
}
```



## 08 无重复字母的最长字串

### 题目

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

### 解答

刷原题也漏洞百出，哎！

哦，剑指offer的笔记还没整理到这里，挽尊了。

就是设置一个指向left的指针，然后依次遍历。

用一个辅助数组来存每个词出现的次数，如果某个地方超过了1，就更新最值，更新为i-left（这是一个连续的子串长度）一直left对应的字母-1，left+1。

然后就能解。

遇到的问题：

1. 最值的更新，在出现重复字串的时候应该有一个更新。
2. 此外，如果没有重复子串出现，也应该有一个更新，所以新开一个变量。
3. 还有就是应该先再left对应字符减一后，再left+1，这里需要纸上分析一下对应关系，不要想当然。

```CPP
int lengthOfLongestSubstring(string s)
{
    int count[200] = {0};
    int max_leng = 0;
    int left = 0;
    int length = s.size();
    int temp=0;
    for (int i = 0; i < length; i++)
    {   temp++;//temp用于没有出现重复值时更新字串长度。
        count[s[i]]++;
        if (count[s[i]] > 1)
        {
            max_leng = max(max_leng, temp);//出现重复时更新目前的最长字串长度。
            while (count[s[i]] > 1)//更新直到不出现重复值。
            {   count[s[left]]--;//记得先减去对应值再++
                left++;
                temp--;//temp也要减
            }
        }
    }
    max_leng = max(max_leng, temp);//最后更新无重复情况。
    return max_leng;
}
```

## 09 找到字符串中所有字母异位词

### 题目

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

### 解答

首先要考虑特判：如果p比s长，return。

其次来考虑这个题。

其实和**02字母异位词分组**思路类似，甚至更简单。

判断是否是异位词，只需要判断每个字母出现的次数是否相同即可。

我们只需要一个长度为p的窗口，从最开始依次划过去进行匹配，如果26个字母出现的次数都相同就证明匹配上了。

初始化时是需要将前p个都纳入其中，然后依次滑动匹配。

```cpp
    vector<int> findAnagrams(string s, string p) {
        int len_p=p.length();
        int len_s=s.length();
        vector<int> ans;
        if(len_p>len_s)return ans;
        int p1[150]={0},s1[150]={0};
        for(int i=0;i<len_p;i++){
            p1[p[i]]++;
            s1[s[i]]++;
        }
        int left=0,right=len_p-1;

        while(1){
                for(int i=95;i<125;i++){//范围可以再缩小一点
                    if(p1[i]!=s1[i])break;
                    if(i==149)ans.push_back(left);
                }
                if(right==len_s-1)break;
            //这里的++位置不同其实是可以改变的，如果初始化的时候right是len_p的话就统一为x++了。
                s1[s[left++]]--;
                s1[s[++right]]++;
        }
    return ans;
    }
```

理论上，在某个位置时可以不break，如果匹配失败，直接在内部进行反复的右滑，直到那个位置匹配上，可减少一些匹配次数，但是实现上需要花点时间，下次再试。

## 10 和为 K 的子数组

### 题目

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

### 解答

如果是单调的正数，可以使用双指针。依次滑动。

前缀和+遍历O（n^2)现在会超时了，但根据题目数据范围，理论上是可行的。

```CPP
int subarraySum(vector<int>& nums, int k) {
    int pre[1000000]={0};
    int length=nums.size();
    int temp=0;
    for(int i=0;i<length;i++){
        temp+=nums[i];
        pre[i+1]=temp;
    }
    int ans=0;
    for(int i=0;i<=length;i++){
        for(int j=i+1;j<=length;j++){
            if(pre[j]-pre[i]==k)ans++;
        }
    }
    return ans;
}
```

所以需要优化一下，时间换空间。

继续前缀和的思路，当我们走到某个位置`i`时。

我们知道，从某位置到i的一个位置j连续子数组的和为pre[i]-pre[j]，如果和为k，则此前出现的所有pre[j]=k-pre[i]均能构成解。

由此用map存每个前缀和出现的次数，遍历一次即可得到答案。

注意把第一个位置给为0，是为什么？为了处理第一个元素就满足的情况（否则此时pre[0]-k=0,证明单个数字就是解）

```CPP
int subarraySum(vector<int> &nums, int k)
{
    int len = nums.size();
    int ans = 0;
    int sum = 0;
    unordered_map<int, int> m;//这里的map是为了存储前缀和的值和出现的次数
    m[0] = 1;//这里的0是为了处理从第一个元素开始就满足条件的情况
    for (int i = 0; i < len; i++)
    {
        sum += nums[i];//这里的sum是从第一个元素开始的前缀和
        if (m.find(sum - k) != m.end())//如果sum-k存在，那么就说明存在一个子数组的和为k
        {
            ans += m[sum - k];
        }
        m[sum]++;
    }
    return ans;
}
```

这道题剑指offer见过，还是只想得起前缀和，想不起map，为什么呢？？

## 11 滑动窗口最大值

### 题目

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

### 解答

全自研的n^2超时了，真该死啊。

```CPP
    int subarraySum(vector<int>& nums, int k) {
        int count = 0;
        for (int start = 0; start < nums.size(); ++start) {
            int sum = 0;
            for (int end = start; end >= 0; --end) {
                sum += nums[end];
                if (sum == k) {
                    count++;
                }
            }
        }
        return count;
    }
```

其实最开始想到了优先队列，但是怎么用没太想清楚，如果会用就好了。

懂了，其实就是我最初的想法：用优先队列存最大值和出现位置，然后如果在范围内就证明是最大值，push进去。

如果不在范围内就pop，总有一个最大值是在范围内的，所以就能解了。

```CPP

//leetcode官方优先队列法。
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    int n = nums.size();
    priority_queue<pair<int, int>> q;//这里这么简单？？
    for (int i = 0; i < k; ++i) {
        q.emplace(nums[i], i);
    }
    vector<int> ans = {q.top().first};
    for (int i = k; i < n; ++i) {
        q.emplace(nums[i], i);
        while (q.top().second <= i - k) {
            q.pop();
        }
        ans.push_back(q.top().first);
    }
    return ans;
}
```

还有一个是单调队列的方法。

假设i在j前面，且num[i]<=num[j]，那么，如果i在窗口内，j也肯定在，那么就不可能选择i，而是选j。所以此时num[i]已经完全可以删除了。

由此规则，可以用一个单调的双端队列来存储未被移除的下标，满足：

1. 下标单调增。
2. 他们对应的值单调减。

此后，每当遇到新元素时，就可以进行比较，如果比队列尾巴大，那么队列尾巴出队，依次比较直到尾巴比新元素大或者队列空了。

然后取值依次从头取，头肯定是最大的元素，如果下标不在窗口内，就头部出队，直到有在窗口内的值出现。

由此就可以实现了，真牛逼。

```CPP
        vector<int> maxSlidingWindow(vector<int>& nums, int k){
            int len=nums.size();
            vector<int> ans;
            deque<int> q;//这里的deque是为了存储下标
            for(int i=0;i<len;i++){
                while(!q.empty()&&nums[q.back()]<nums[i])q.pop_back();//这里的while是为了保证队列中的元素是单调递减的
                q.push_back(i);
                if(q.front()==i-k)q.pop_front();//这里的if是为了保证队列中的元素是在滑动窗口中的
                if(i>=k-1)ans.push_back(nums[q.front()]);//这里的if是为了保证队列中的元素是在滑动窗口中的
            }
            return ans;
        }
```

还有一个，分块处理的办法，感觉好牛逼，但不想看了，再说吧。

## 12 最小覆盖字串

### 题目

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的`最小子串`。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

### 解答

自己把题目想简单了，没考虑到有多个串都包含所需要的，但是最短的只有一个的条件。

所以实际上实现的是找到一个满足条件的字串，但不一定最短。

```cpp
string minWindow(string s, string t)
{
    int left = 0;
    int right = s.length() - 1;
    int array[200] = {0}, array2[200] = {0};
    int len_s = s.length();
    int len_t = t.length();
    string ans;
    if (len_s < len_t)
    {
        return ans;
    }
    for (int i = 0; i < len_t; i++)
    {
        array[t[i]]++;
    }
    for (int i = 0; i < len_s; i++)
    {
        array2[s[i]]++;
    }
    for (int i = 0; i < 200; i++)
        {
            if (array[i] > array2[i])
                return ans;
        }
    while (1)
    {

        if(array2[s[right]]>array[s[right]]){
            array2[s[right]]--;
            right--;
        }
        else if(array2[s[left]]>array[s[left]]){
            array2[s[left]]--;
            left++;
        }
        else{
            break;
        }

    }
    return s.substr(left,right-left+1);
}
```

但其实这种方法已经很接近了，只需要再次执行直到找到全局最优解。

（好像也不太对，因为这样要多次从最右端开始遍历，比较麻烦）

正确思路是：

从最右端开始，右指针依次扩张直到包含所有需要的字符，然后左指针增加，直到增加会导致不满足条件。

从这里看和上面的方法差不多，但更重要的是找最小。

此时我们已经拿到了一个满足题意的，但我们要判断是否是最小。

我们先把此时的记录下来，然后left++，此时肯定已经不满足要求了，那么右指针继续增加，直到找到下一个范围，左指针再增加直到最小。

这样每次都能比较，找到那个最小的窗口长度，进行更新。

最后得到结果。

我们用一个count记录出现的在t中包含字符的次数，意思是说当count=t的时候证明所有数字都包含。（更新的时候只会更新在map中还不为0的）。

```CPP
string minWindow(string s, string t){
    int len_s=s.length();
    int len_t=t.length();
    int left=0,right=0;
    int ans_left=0,ans_right=0;
    int min_len=INT_MAX;
    int count=0;//这里的count是为了记录窗口中的字符是t中的字符的个数
    unordered_map<char,int> m;
    for(int i=0;i<len_t;i++){
        m[t[i]]++;//这里的map是为了存储t中每个字符出现的次数
    }
    while(right<len_s){//这里的while是为了保证窗口的右边界不越界
        if(m.find(s[right])!=m.end()){//这里的if是为了保证s中的字符是t中的字符
            m[s[right]]--;//有可能出现多个相同的字符，所以这里的map中的值是可以为负数的
            if(m[s[right]]>=0)count++;
            while(count==len_t){//这里的while是为了保证窗口中的字符是t中的字符
                if(right-left+1<min_len){//找到了一个更小的窗口，更新min_len
                    min_len=right-left+1;
                    ans_left=left;//这里的ans_left和ans_right是为了记录最小窗口的左右边界
                    ans_right=right;
                }
                if(m.find(s[left])!=m.end()){//这里是说left指向的字符是t中的字符
                    m[s[left]]++;
                    if(m[s[left]]>0)count--;//当m[s[left]]==0的时候，说明窗口中的字符不是t中的字符了。
                }
                left++;
            }
        }
        right++;
    }
    if(min_len==INT_MAX)return "";
    return s.substr(ans_left,min_len);//这里的substr是为了返回最小窗口的字符串
}
```

写起来真困难啊！

## 13 最大子数组和

### 题目

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

### 分析解答

动态规划真是难懂啊。

分析：求最大子数组和，可以转化为求以num[i]作为结尾的子数组中，对应值最大那个。

那么第一个值就应该是num[0],

我们在更新下一个位置`i`时，只需要看看以`i-1`结尾对应的最大子数组值：

如果`i-1`对应的是一个负值，那么i对应的最长子数组就应该是它本身（不然加上前面任意一个值，结果仍然是负数），否则，就是`i-1`对应的值再加`i`.

状态转移方程：
$$
f(i)=max\{f(i-1)+num[i],num[i]\}
\\求：\\
max\{f(i)\}
$$


```cpp
int maxSubArray(vector<int> &nums)
{
    int len = nums.size();
    int ans = nums[0];
    vector<int> dp(len);
    dp[0] = nums[0]; // dp[i]表示以nums[i]结尾的最大子序和，第一个元素的最大子序和就是它本身
    for (int i = 1; i < len; i++)
    {
        dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移方程
        ans = max(ans, dp[i]);//实际上可以不用dp数组，直接用ans记录最大子序和。
    }
    return ans;
}
```

这里因为只用求最大的值，实际上dp数组是没用的（意思是并不需要一个数组来记录值，只用一个变量就可以，因为我们一直在用max更新答案）。

#### 分治法

假设我们定义`maxSubArrayHelper(nums,left,right)`，表示nums数组中从子数组[left,right]长度的最大子数组和，那么我们题目所需要求的就是left=0,right=len-1的情况。

我们通过分治法，设一个值为*m*=⌊(l+r)/2⌋，分别计算左右区间[l,m],[m+1,r]的解。当长度为1时，解就是目前的值。然后逐层向上递归，合并区间信息，最终得到答案。

但问题是在合并时需要哪些信息？

在更新过程中我们需要：

1. 左端点开头的的最大和
2. 右右端点结尾的最大和
3. 左右区间合并后整个区间的和
4. 区间内的最大和

合并时需要对这几个值更新：

对于整个区间的和，就是左右区间的和相加。

对左边和的更新：

要么是左区间最大和，要么是左区间整段和加上右区间的最大和。取最大。

右边和同理。

对于最大值的更新，它要么是左区间最大和，要么是右区间最大和，如果穿过了中间，那么就是做区间的右边和加上右区间的左边和。三者取最大。

```CPP
int crossSumHelper(vector<int> &nums, int left, int right, int mid)
{
    if (left == right)
        return nums[left];
    int leftSubSum = INT_MIN;
    int currSum = 0;
    for (int i = mid; i > left - 1; i--)
    {
        currSum += nums[i];
        leftSubSum = max(leftSubSum, currSum);
    }
    int rightSubSum = INT_MIN;
    currSum = 0;
    for (int i = mid + 1; i < right + 1; i++)
    {
        currSum += nums[i];
        rightSubSum = max(rightSubSum, currSum);
    }
    return leftSubSum + rightSubSum;
}
int maxSubArrayHelper(vector<int> &nums, int left, int right)
{
    if (left == right)
        return nums[left];
    int mid = (left + right) / 2;
    int leftSum = maxSubArrayHelper(nums, left, mid);
    int rightSum = maxSubArrayHelper(nums, mid + 1, right);
    int crossSum = crossSumHelper(nums, left, right, mid);
    return max(max(leftSum, rightSum), crossSum);
}
int maxSubArray(vector<int> &nums)
{
    int len = nums.size();
    if (len == 0)
        return 0;
    return maxSubArrayHelper(nums, 0, len - 1);
}
```

## 14 合并区间

### 题目

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

### 解答

先将区间按照左端点排序，然后依次合并。

合并的过程：

记录区间为a，b。

用l和r记录a区间的左和右端点。

如果r>=b左端点，证明二者可以合并。

更新r为r和b右端点的较大值。

否则，证明区间不连续了，直接将{l，r}加入区间中。

然后将l和r更新为b的对应值。

最后记得将最后一个区间加入其中。

```CPP
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    vector<vector<int>> ans;
    int len=intervals.size();
    if(len==0)return ans;
    sort(intervals.begin(),intervals.end());//按照区间的左边界进行排序
    int left=intervals[0][0];//初始化左边界
    int right=intervals[0][1];//初始化右边界
    for(int i=1;i<len;i++){
        if(intervals[i][0]<=right){
            right=max(right,intervals[i][1]);//如果当前区间的左边界小于等于右边界，说明两个区间有重叠，更新右边界
        }
        else{//否则，说明两个区间没有重叠，将当前区间加入到ans中，更新左右边界为新区间的值。
            ans.push_back({left,right});
            left=intervals[i][0];
            right=intervals[i][1];
        }
    }
    ans.push_back({left,right});//最后一个区间还没有加入到ans中，这里加入到ans中
    return ans;
}
```

![image-20240113110853028](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20240113110853028.png)

此外还有自己想的还需要改进的算法，复杂度大概n方，能过大部分点，但有种情况无法解决。

```cpp

vector<vector<int>> merge2(vector<vector<int>>& intervals) {
    int helper[10001]={0};//helper[i]表示i出现的次数
    int len=intervals.size();
    for(int i=0;i<len;i++){
        for(int j=intervals[i][0];j<=intervals[i][1];j++){
            helper[j]++;//统计每个数出现的次数
        }
    }
    vector<vector<int>> ans;
    int left=0;
    int right=0;
    while(right<10001){
        if(helper[right]==0){//如果helper[right]==0，说明right不在任何一个区间中，将[left,right-1]加入到ans中
            if(left!=right)ans.push_back({left,right-1});
            left=right+1;//更新left
        }
        right++;
    }
    //如何处理相邻区间？诸如[1,2],[3,4]这样的会被算作两个的区间?
    //问题可能出现在，数组下标并不是数轴上的连续，以点来标记会出问题。
    return ans;
}
```

## 15 轮转数组

### 题目

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

### 解答

哎哎哎，简单直接法确实简单直接。

reverse三次的做法看见过，但是没有马上想起来，淦。

然后就是环状替换，好难，哎。

大概意思是，每隔k个位置就跳着更新一圈。

当一段之间后会回到原位，但此时还没更新完，需要从下一个位置开始继续更新。

每一次回到原位的过程更新了多少个值？更新了lcm（n，k）/k，那么我们总共需要循环gcd(n,k)次（最小公倍数）。

```CPP
void rotate(vector<int>& nums, int k) {
    //旋转大法，时间复杂度O(n)，空间复杂度O(1)
    int len=nums.size();
    k=k%len;
    reverse(nums.begin(),nums.end());
    reverse(nums.begin(),nums.begin()+k);
    reverse(nums.begin()+k,nums.end());
}
void rotate2(vector<int>& nums, int k) {
    //环状替换，时间复杂度O(n)，空间复杂度O(1)
    //这个比较悬幻，不太好理解
    //就是说，每次将当前元素移动到正确的位置，直到所有元素都移动到正确的位置
    //这里的正确位置是指，当前元素移动k次之后的位置
    //count用来记录移动了多少个元素
    //current用来记录当前元素的位置
    //prev用来记录当前元素移动之前的元素
    int len=nums.size();
    k=k%len;
    int count=0;
    for(int start=0;count<len;start++){
        int current=start;
        int prev=nums[start];
        do{
            int next=(current+k)%len;//next表示当前元素移动k次之后的位置
            int temp=nums[next];//temp表示当前元素移动之前的元素
            nums[next]=prev;//将当前元素移动到正确的位置
            prev=temp;//更新prev
            current=next;//更新current
            count++;//更新count
        }while(start!=current);//当start==current的时候，说明当前元素移动了k次之后又回到了原来的位置，这时候就要更新start
    }
    //count也可以改为gcd(len,k)，这样for循环改为for(int start=0;start<gcd(len,k);start++)。
}
void rotate3(vector<int>& nums, int k) {
    //时间复杂度O(n)，空间复杂度O(n)
    //简单直接，开辟一个新的数组，将原数组中的元素放到新数组中正确的位置。
    int len=nums.size();
    k=k%len;
    vector<int> ans(len);
    for(int i=0;i<len;i++){
        ans[(i+k)%len]=nums[i];
    }
    nums=ans;
}
```

## 16 除自身以外数组的乘积

### 题目

给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。

### 解答

存一个前缀积和一个后缀积，结果数组的每个位置就等于前缀乘上后缀。

```CPP
vector<int> productExceptSelf(vector<int>& nums) {
    vector<int> helper,ans;
    int len=nums.size();    
    helper.push_back(1);
    for(int i=1;i<len;i++){
    helper.push_back(helper[i-1]*nums[i-1]);
    }
    vector<int> helper2(len);
    helper2[len-1]=1;
    for(int i=len-2;i>=0;i--){
        helper2[i]=helper2[i+1]*nums[i+1];
    }
    for(int i=0;i<len;i++){
        ans.push_back(helper[i]*helper2[i]);
    }
    return ans;
}
```

但还可以进一步优化，优化掉helper2。

用ans代替helper1。

我们的ans从后往前来算，然后增加一个right作为辅助元素，代替辅助数组。

helper1一边向前遍历，right一边乘新拿到的num[i]代表目前的后缀。

这样可以优化一下空间复杂度为常数级别。

由于使用了ans作为一个helper1，甚至不用在最后再逆转ans了，因为ans[len-1]是已经有了值可以取的。

```CPP
vector<int> productExceptSelf(vector<int>& nums) {
    int len=nums.size();
    vector<int> ans(len);
    ans[0]=1;
    for(int i=1;i<len;i++){
        ans[i]=ans[i-1]*nums[i-1];
    }
    int R=1;
    for(int i=len-1;i>=0;i--){
        ans[i]=ans[i]*R;
        R=R*nums[i];
    }
    return ans;

}
```

## 17 未出现的最小正数

### 题目

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

### 解答

这个题的难点主要有两个：

1. 看出来未出现过的最小正数只会是0到n+1中的一个。（这个看不出来就死了）
2. 只用常数级别额外空间且时间复杂度为n。

如果没有`2.`，那么我们直接把它放进一个set里面，依次查找就可以了。

```CPP
    int firstMissingPositive(vector<int>& nums) {
        unordered_set<int> s;
        for(int i=0;i<nums.size();i++){
            s.insert(nums[i]);
        }
        int i=1;
        while(s.find(i)!=s.end()){
            i++;
        }
        return i;

    }
```

但这会超过空间要求，所以需要改进。

改进的思路是`原地哈希`，就是遍历一次数组，将每个数字放到它对应的位置上。

利用哈希函数：

f(nums[i]) = nums[i] - 1）

那么在这个过程中，需要注意对出现相同元素的情况进行一下处理。

```CPP
int firstMissingPositive(vector<int>& nums) {
        int len = nums.size();
        for(int i = 0; i < len; i++){
            //while循环在过程中会把nums[i]放到它应该在的位置上。
            //如果有一些元素在这一次的循环中被交换到了它们应该在的位置，那么下一次循环就会跳过这些元素。
            //所以while不会每次都遍历所有的元素，最终时间复杂度是O(n)。
            while(nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]){
                //判断分别是为了判断nums[i]是否在[1,len]之间，以及nums[i]是否已经在它应该在的位置上
                //如果出现重复元素，那么就会出现死循环，所以需要判断nums[nums[i] - 1] != nums[i]
                swap(nums[i], nums[nums[i] - 1]);//这里的交换是为了把nums[i]放到它应该在的位置上
            }
        }
        for(int i = 0; i < len; i++){
            if(nums[i] != i + 1){//这里的判断是为了找到第一个不满足nums[i] == i + 1的元素
                return i + 1;
            }
        }
        return len + 1;

    }
```

## 18 矩阵置零

### 题目

给定一个 `m x n` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

### 解答

直观想到的当然是用一个mn的备用矩阵来记录，但实际上可以优化：其实只用m+n的空间，记录行和列，需要置为0时就对应的行和列标记为0，最后遍历一下修改就可。

```CPP
void setZeroes(vector<vector<int>> &matrix)
{
    int m = matrix.size();
    int n = matrix[0].size();
    vector<int> row(m), col(n);
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (!matrix[i][j])
            {
                row[i] = col[j] = true;
            }
        }
    }
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (row[i] || col[j])
            {
                matrix[i][j] = 0;
            }
        }
    }
}
```

但这没达到题目要求的常数级别，所以需要进一步优化：
我们可以用原本数组的第一列和第一行来作为标记数组。(如果col[i]\[j\]是0，那么col[i\][0]和col[0][j\]也都是0，用它来做标记并不会影响本不会被修改的第一行和第一列，这只是可能会导致原本的第一行或第一列的0与后来放置的0无法区分，所以才需要标记。）

我们用额外的两个变量来做标记，进行预处理。

使用其他行与列来处理第一列和第一行，作为标记数组，再用之去更新其他行与列，最后使用两个标记变量是否为0来更新第一行与第一列即可。

```CPP
void setZeroes(vector<vector<int>>& matrix) {
    //空间复杂度为O(1)
    int m = matrix.size();
    int n = matrix[0].size();
    bool row = false;
    bool col = false;//这两个bool值是为了判断第一行和第一列是否需要置0
    //辅助空间是两个数组，分别存储第一行和第一列是否需要置0
    for(int i = 0; i < m; i++){
        if(matrix[i][0] == 0){
            col = true;
            break;
        }
    }
    for(int i = 0; i < n; i++){
        if(matrix[0][i] == 0){
            row = true;
            break;
        }
    }
    for(int i = 1; i < m; i++){
        for(int j = 1; j < n; j++){
            if(matrix[i][j] == 0){
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    for(int i = 1; i < m; i++){
        if(matrix[i][0] == 0){
            for(int j = 1; j < n; j++){
                matrix[i][j] = 0;
            }
        }
    }
    for(int i = 1; i < n; i++){
        if(matrix[0][i] == 0){
            for(int j = 1; j < m; j++){
                matrix[j][i] = 0;
            }
        }
    }
    if(row){
        for(int i = 0; i < n; i++){
            matrix[0][i] = 0;
        }
    }
    if(col){
        for(int i = 0; i < m; i++){
            matrix[i][0] = 0;
        }
    }
}
```

还能进一步优化：仅用列标记第一列是否出现0。

这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新，我们需要从最后一行开始，倒序地处理矩阵元素。

## 19 螺旋矩阵

### 题目

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

### 解答

最简单的当然是用辅助矩阵来做标记，相当于记录路劲。但可以简化：

就是用几个变量，分别标记左右上下边界。

然后每次循环都按照顺序对其进行访问。

访问之后需要更新边界上下左右（相当于往中间收缩一层。）

什么时候结束呢？结束条件是上下或者左右出现交错时。

我们在中间加了一个if的判断，是很重要的：如果还没交错，但所有的都取了同一个值，这时候遍历会有重复的可能，这是为了避免这种情况（比如说3*3的矩阵，不加判断就会出现问题，有重复）

```CPP
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    vector<int> ans;
    int m = matrix.size();
    if(m == 0){
        return ans;
    }
    int n = matrix[0].size();
    int left = 0;
    int right = n - 1;
    int top = 0;
    int bottom = m - 1;
    while(left <= right && top <= bottom){
        for(int i = left; i <= right; i++){
            ans.push_back(matrix[top][i]);//这里的i是从left开始的，所以是<=right
        }
        for(int i = top + 1; i <= bottom; i++){//top+1是为了避免重复
            ans.push_back(matrix[i][right]);//这里的i是从top + 1开始的，所以是<=bottom
        }
        if(left < right && top < bottom){//这里的判断是为了避免重复,因为上面的两个for循环可能会把下面的两个for循环包含进去
            for(int i = right - 1; i > left; i--){
                ans.push_back(matrix[bottom][i]);//这里的i是从right - 1开始的，所以是>left
            }
            for(int i = bottom; i > top; i--){
                ans.push_back(matrix[i][left]);//这里的i是从bottom开始的，所以是>top
            }
        }
        left++;
        right--;
        top++;
        bottom--;
    }
    return ans;
}
```

## 20 旋转图像

### 题目

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

### 解答

这个题感觉挺简单？

就，从四个角开始依次对应位置进行旋转，然后一圈一圈地进行到最中间。

难点可能是边界条件的判断，最开始想要不要分奇偶来看，但应该不需要，就直接就可以了。（奇数情况下中间元素转四次还是他自己。）

```CPP
void rotate(vector<vector<int>>& matrix) {
    int n = matrix.size();
    for(int i = 0; i < n / 2; i++){
        //程序运行到中心的时候就停止了，所以这里的i < n / 2，而不是i < n。
        for(int j = i; j < n - i - 1; j++){
            //这里的思路是先把matrix[i][j]放到它应该在的位置上，然后再把matrix[n - j - 1][i]放到它应该在的位置上，以此类推
        
            //为什么是n-j-1而不是n-j，因为matrix[n - j - 1][i]是matrix[i][j]顺时针旋转90度后的位置
            int temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
        }
    }

}
```





## 21 搜索二维矩阵 Ⅱ

### 题目

编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

### 解答

最简单的想法自然是m*n的遍历搜索。

其次是对行或者列，在搜索中用二分法。可以mlgn或nlgm。

**不能行和列同时二分是因为第一行的末尾不一定大于第二行的开头**

最好的方法是从左上角或者右下角开始进行搜索。

为什么？

因为这样的话，你可以放心地更新一行或者一列：

我们以左下角为例：

如果元素大于target，由行递增可知不会出现在这一行，列标可以放心-1.

如果元素小于target，由列递增可知，不会出现在当前列，行标可以放心+1.

如果遇到了target，那么就返回true。

否则，如果最后行或者列超出范围，就证明找不到，返回false。

当然了。出于局部性的考虑，从右上角开始，可能会更好一点。

```CPP
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m=matrix.size();
    int n=matrix[0].size();
    int i=0,j=n-1;
    while(i<m&&j>=0){
        if(matrix[i][j]==target){
            return true;
        }
        else if(matrix[i][j]>target){
            j--;
        }
        else{
            i++;
        }
    }
    return false;
}
```



**还可以抽象为一个从左下角或者右上角开始的二叉查找树（BST）**

以右上角为例，左边是小的，下边是大的，然后类似于查找的遍历法。左子树是左边，右子树是下边。

## 22 相交链表

### 题目

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

### 解答

**一个简单的想法是**，将其中一个塞到哈希表里，然后另外一个依次判断每个元素是否在其中，在的话就过了，返回。如果一直没有重复元素知道遍历结束，就证明不相交。

这个空间消耗比较大。

```CPP
 struct ListNode {
      int val;
      ListNode *next;
      ListNode(int x) : val(x), next(NULL) {}
  };
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    unordered_set<ListNode*> s;
    while(headA){
        s.insert(headA);
        headA=headA->next;
    }
    while(headB){
        if(s.find(headB)!=s.end()){
            return headB;
        }
        headB=headB->next;
    }
    return NULL;
}
```

进一步的想法是，可以将链表反转，判断首元素，再依次判断各个元素直到找到第一个不相交的。

但题目要求不改变原链表，所以可以在运行结束后再reverse一次。

因为反转的复杂度on，所以反转两次也还是on，虽然慢点但是能跑,但其实不太好实现，因为过程中还需要保存头结点啥的为了reverse能用，感觉比较麻烦。

神中神的是下面的解法：

1. 指针a，b分别是指向二者头结点
2. 同时向后移动
3. 如果a后一个为空，就跳到b的头结点
4. 如果b后一个为空，就跳到a的头结点
5. 然后直到二者相遇，返回。
6. 否则走完两个链表还没有解，就null。

分析：

倒着考虑，假设二者都走完两个表还没返回，那肯定是不相交。

假设二者香蕉部分有a个，两个指针会同时走到n+m-a，此时就可判断出相交了。

```CPP
 struct ListNode {
      int val;
      ListNode *next;
      ListNode(int x) : val(x), next(NULL) {}
  };
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *p=headA,*q=headB;
        while(p!=q){
            p=p==NULL?headB:p->next;
            q=q==NULL?headA:q->next;
        }
        return p;
    }
```

## 23 反转链表

### 题目

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

### 解答

其实就挨个点反转就可以了，只是要注意当你反转一个点的时候会丢失后继，所以得单独用一个变量来吧后继先存起来，再反转。

```CPP
ListNode *reverseList(ListNode *head) {
    ListNode *pre = NULL;
    ListNode *cur = head;
    while (cur != NULL) {
        ListNode *nextTemp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = nextTemp;
    }
    return pre;
}
```

当然，有一种递归的办法来进行求解：

需要注意的是，第一个结点的后继必须指向null，否则可能有环。



```CPP
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}

作者：力扣官方题解
链接：https://leetcode.cn/problems/reverse-linked-list/solutions/551596/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/
来源：力扣（LeetCode）
```

## 24 回文链表

### 题目

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

### 解答

方法一

复制到数组中，然后两头向中间一次比较，直到二者交错（这里要注意等号的问题（奇数和偶数））

```cpp
  struct ListNode {
      int val;
     ListNode *next;
      ListNode() : val(0), next(nullptr) {}
      ListNode(int x) : val(x), next(nullptr) {}
     ListNode(int x, ListNode *next) : val(x), next(next) {}
  };
bool isPalindrome(ListNode* head) {
    if(head==NULL||head->next==NULL){
        return true;
    }
    int len=0;
    ListNode* p=head;
    while(p!=NULL){
        len++;
        p=p->next;
    }
    int array[len];
    p=head;
    for(int i=0;i<len;i++){
        array[i]=p->val;
        p=p->next;
    }
    for(int i=0;i<len/2;i++){
        if(array[i]!=array[len-i-1]){
            return false;
        }

    }
    return true;
}
```

方法二是通过反转链表的方式。

用一个快指针和一个慢指针，直到一个指向末尾，一个指向一半的位置。

这个时候再对其中一半进行反转之后，依次比较就可以。

```CPP
bool isPalindrome(ListNode* head) {
    if(head==NULL||head->next==NULL){
        return true;
    }
    ListNode* slow=head;
    ListNode* fast=head;
    while(fast->next!=NULL&&fast->next->next!=NULL){
        slow=slow->next;
        fast=fast->next->next;
    }
    ListNode* pre=slow;
    ListNode* cur=slow->next;
    ListNode* next;
    while(cur!=NULL){
        next=cur->next;
        cur->next=pre;
        pre=cur;
        cur=next;
    }
    slow->next=NULL;
    ListNode* p1=head;
    ListNode* p2=pre;
    while(p1!=NULL&&p2!=NULL){
        if(p1->val!=p2->val){
            return false;
        }
        p1=p1->next;
        p2=p2->next;
    }
    return true;
}
```

当然，还能更进一步，目前这个方法是在找到中间节点后再重新开始反转，实际上在快慢指针运行时就可以进行反转了，（我们针对slow做这个处理，边遍历边反转）

```CPP
bool isPalindrome(ListNode* head) {
    if(head==NULL||head->next==NULL){
        return true;
    }
    ListNode* slow = head, *fast = head;
    ListNode* pre = head, *prepre = NULL;
        while(fast!=NULL&&fast->next!=NULL){//找到中间节点，同时反转前半部分链表
            pre = slow;
            slow = slow->next;
            fast = fast->next->next;
            pre->next = prepre;
            prepre = pre;
        }
        if(fast!=NULL){//奇数个节点的情况，跳过中间节点
            slow = slow->next;
        }
        while(pre!=NULL&&slow!=NULL){//比较前半部分和后半部分链表
            if(pre->val!=slow->val){
                return false;
            }
            pre = pre->next;
            slow = slow->next;
        }
        return true;
}
```

## 25 环形链表

### 题目

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

### 解答

就一个快慢指针的问题，相遇就一定有环，不相遇到null就没有。

```CPP
bool hasCycle(ListNode *head)
{
    ListNode *slow = head, *fast = head;
    while (fast != NULL && fast->next != NULL)
    { // 快慢指针
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
        { // 相遇
            return true;
        }
    }
    return false;
}
```

## 26 环形链表Ⅱ

### 题目

在上一题的基础上，如果有环，返回环起始位置，否则返回null。

### 解答

只管解法依然是大力出奇迹，用个哈希表存起来。

```CPP
ListNode *detectCycle(ListNode *head) {
    unordered_set<ListNode*> visited;
    while (head != nullptr) {
        if (visited.count(head)) {
            return head;
        }
        visited.insert(head);
        head = head->next;
    }
    return nullptr;
}
```

升级版本也是双指针：

根据等量关系，从相遇点到入环点的距离加上n-1 圈的环长，恰好等于从链表头部到入环点的距离。

![image-20240115120224145](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20240115120224145.png)

所以我们增加一个额外的指针，当相遇后，新指针从头开始，然后也依次向后移动一个位置，和慢指针相遇的位置就是环的入口。

![image-20240115124716852](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20240115124716852.png)

```CPP
ListNode *detectCycle(ListNode *head) {
    ListNode *slow = head, *fast = head;
    while (fast != NULL && fast->next != NULL)
    { // 快慢指针
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
        { // 相遇
            ListNode *index1 = fast;
            ListNode *index2 = head;
            // 从相遇点到环入口的距离等于链表头到环入口的距离
            // 从链表头和相遇点同时出发，相遇的地方就是环的入口
            while (index1 != index2)
            {
                index1 = index1->next;
                index2 = index2->next;
            }
            return index1;
        }
    }
    return NULL;
}
```

## 27 合并链表

### 题目

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

### 解答

其实很简单就是依次比较把小的插入就可以了，直到某个链表为空，把剩下的那部分再接上去就可以了。

```cpp
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode *newHead = new ListNode(-1);
    ListNode *cur = newHead;
    while (list1 != NULL && list2 != NULL)
    {
        if (list1->val < list2->val)
        {
            cur->next = list1;
            list1 = list1->next;
        }
        else
        {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    }
    if (list1 != NULL)
    {
        cur->next = list1;
    }
    if (list2 != NULL)
    {
        cur->next = list2;
    }
    return newHead->next;
}
```

值得注意的是递归的写法，可以借鉴参考。

```CPP
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr) {
            return l2;
        } else if (l2 == nullptr) {
            return l1;
        } else if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/merge-two-sorted-lists/solutions/226408/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/
来源：力扣（LeetCode）
```

## 28 两数相加

### 题目

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

### 解答

就直接相加就行了，需要注意的是不能够直接转为整数再转回链表（溢出）。

还有就是进位的flag要怎么处理需要注意一下：new_flag=(x+y+old_flag)/10。

```CPP
ListNode *addTwoNumbers(ListNode *l1, ListNode *l2)
{
 ListNode *newHead = new ListNode(-1);
    ListNode *cur= newHead;
    int flag=0;
    while(l1!=NULL||l2!=NULL){
        int x=(l1==NULL)?0:l1->val;
        int y=(l2==NULL)?0:l2->val;
        int sum=x+y+flag;
        flag=sum/10;
        cur->next=new ListNode(sum%10);
        cur=cur->next;
        if(l1!=NULL)l1=l1->next;
        if(l2!=NULL)l2=l2->next;
    }  
    if(flag>0){
        cur->next=new ListNode(flag);
    }
    return newHead->next;
}
```

## 29 删除链表的倒数第n个结点

### 题目

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

### 解答

就直接用两个指针，加一个计数元素。当计数元素到count的时候，第一个和第二个指针一起动。

第一个指针指向末尾时，第二个指针指向的就是倒数第n个了，这时候再删除然后返回头结点就可以。

```CPP
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *newHead = new ListNode(-1);
        newHead->next = head;
        ListNode *slow = newHead, *fast = newHead;
        for (int i = 0; i < n; i++)
        {
            fast = fast->next;
        }
        while (fast->next != NULL)
        {
            slow = slow->next;
            fast = fast->next;
        }
        slow->next = slow->next->next;
        return newHead->next;
    }
```

当然，也可以根据栈的后进先出，全部入栈再依次出栈来解决。

## 30 *两两交换链表中的节点

### 题目

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

### 解答

由于不能直接修改节点内部的值，所以我们只能直接操作结点。

用两个临时指针把要交换的点先取出来，然后交换就可以了。

很简答的关系，就直接画一下就能表示清楚了。

```CPP
ListNode* swapPairs(ListNode* head) {
    ListNode *newHead = new ListNode(-1);
    newHead->next = head;
    ListNode *cur = newHead;
    while (cur->next != NULL && cur->next->next != NULL)
    {
        ListNode *temp1 = cur->next;
        ListNode *temp2 = cur->next->next;
        cur->next = temp2;
        temp1->next = temp2->next;
        temp2->next = temp1;
        cur = temp1;
    }
    return newHead->next;
}
```

## 31 K个一组翻转链表

### 题目

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

### 解答

可以基于23题反转链表的操作。

这里所须要注意的是比较繁琐的操作与边界判断等。

我们用temp变量辅助取下k个结点，通过23题的函数来反转。

这里要注意一下，在取下k个节点后，应该用一个新变量来存储k之后的那个（不然就断开了），同时把取下的这一段的尾节点之后置为空（不然就把整个链表反转了）

同时反转后记得要和之前的部分接上。

```CPP
ListNode* reverseKGroup(ListNode* head, int k) {
    ListNode *newHead = new ListNode(-1);
    newHead->next = head;//newHead用来记录头节点
    ListNode *cur = newHead;
    while (cur->next !=NULL){
        ListNode *temp = cur;//temp用来记录每一组的头节点
        for (int i = 0; i < k && temp != NULL; i++)//判断是否有k个节点
        {
            temp = temp->next;
        }
        if (temp == NULL)//如果不足k个节点，直接退出循环，证明已经到了最后一组，不用反转。
        {
            break;
        }
        ListNode *temp1 = cur->next;
        ListNode *temp2 = temp->next;
        //temp1是每一组的头节点，temp2是每一组的尾节点的下一个节点
        temp->next = NULL;
        cur->next = reverseList(temp1);
        //cur指向反转后的头节点，temp1指向反转后的尾节点。
        //反转后要吧temp2和temp1连接起来，所以要用temp1->next = temp2;
        //然后cur指向temp1，继续下一组的反转。
        temp1->next = temp2;
        cur = temp1;
    }
    return newHead->next;
    }
```

## 32 随机链表的复制

### 题目

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

### 解答

难点在于，当你拷贝第i个节点时，它的random所指向的结点可能还没被创建出来。

有一种方法是，用哈希表记录已经创建的结点，每次需要random的节点时，如果在表中找不到，就把random指向的结点记录下来，然后依次回溯就能够得到它所指的结点。

另外一种方法是，我们把表延长扩展。

在每个结点后面新增一个结点，与它具有相同值。

新增的结点单独穿成串，就是我们所需要的新链表。

此时还需要处理random指针。

假设A指向B，那么我们知道，A在深复制后的结点为A\`,B在深复制后的结点为B\`。

我们只需要：

> A->next->random=A->random->next

就能够实现random的串联。(当然，null需要特判)

最后再遍历一遍，把带有\`的结点取下来就可以了。(注意取下之后把原本的数组恢复原样。)

```CPP
Node* copyRandomList(Node* head) {
    if (head == NULL)
    {
        return NULL;
    }
    Node *cur = head;
    //在每个节点后面插入一个新节点，val和next都和原来的节点一样
    while (cur != NULL)
    {
        Node *temp = new Node(cur->val);
        temp->next = cur->next;
        cur->next = temp;
        cur = temp->next;
    }
    cur = head;
    //设置新节点的random指针
    while (cur != NULL)
    {
        if (cur->random != NULL)
        {
            //cur->next是新节点，cur->random->next是原来节点的random指针指向的节点
            cur->next->random = cur->random->next;
        }
        
        cur = cur->next->next;
    }
    cur = head;
    Node *newHead = head->next;
    while (cur != NULL)
    {//把新节点和原来的节点分开
        Node *temp = cur->next;
        cur->next = temp->next;
        if (temp->next != NULL)
        {
            temp->next = temp->next->next;
        }
        cur = cur->next;
    }
    return newHead;
}
```

## 33 排序链表

### 题目

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

### 解答

在没有别的要求限制时，可以：

1. 直接插入排序，o（n^2）
2. 复制到数组排序再建表，o(nlgn)，但是空间消耗比较大。

最好的话可以选择归并排序。

自底向上。

自顶向下的话，会递归调用栈，空间复杂度更高。

```CPP
ListNode* sortList(ListNode* head) {//自顶向下归并排序//复杂度O(nlogn)，空间复杂度O(logn)
        if (head == NULL || head->next == NULL)
        {
            return head;
        }
        int len = 0;
        ListNode *cur = head;
        while (cur != NULL)
        {
            len++;
            cur = cur->next;
        }
        ListNode *newHead = new ListNode(-1);
        newHead->next = head;
        for (int i = 1; i < len; i *= 2)
        {
            ListNode *prev = newHead;
            cur = newHead->next;
            while (cur != NULL)
            {
                ListNode *h1 = cur;
                ListNode *h2 = split(h1, i);
                //h1是第一组的头节点，h2是第二组的头节点
                //split函数的作用是把h1分成两组，第一组有i个节点，第二组有len-i个节点
                //cur指向第二组的头节点
                //merge传入两个链表的头节点，返回合并后的头节点。
                cur = split(h2, i);
                prev->next = merge(h1, h2);
                //每次merge都相当于排好了2*i个节点，所以prev要指向排好序的最后一个节点。
                while (prev->next != NULL)
                {
                    prev = prev->next;
                }
            }
        }
        return newHead->next;
  }
ListNode* split(ListNode *head, int n)
{//把链表分成两组，第一组有n个节点，第二组有len-n个节点。
//返回第二组的头节点。
    for (int i = 1; head != NULL && i < n; i++)
    {
        head = head->next;
    }
    if (head == NULL)
    {
        return NULL;
    }
    ListNode *second = head->next;
    head->next = NULL;
    return second;
}
ListNode* merge(ListNode *h1, ListNode *h2)
{
    ListNode *newHead = new ListNode(-1);
    ListNode *cur = newHead;
    while (h1 != NULL && h2 != NULL)
    {
        if (h1->val < h2->val)
        {
            cur->next = h1;
            h1 = h1->next;
        }
        else
        {
            cur->next = h2;
            h2 = h2->next;
        }
        cur = cur->next;
    }
    if (h1 != NULL)
    {
        cur->next = h1;
    }
    if (h2 != NULL)
    {
        cur->next = h2;
    }
    return newHead->next;
}
```

## 34 合并k个升序链表

### 题目

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

### 解答

1. 直接合并，每次进行一个两个链表的合并，直到最后只剩一个链表。

   ```cpp
       ListNode* mergeKLists(vector<ListNode*>& lists) {
           //每次合并两个数组，直到最后只剩一个。
           if (lists.size() == 0)
           {
               return NULL;
           }
           ListNode *res = lists[0];
           for (int i = 1; i < lists.size(); i++)
           {
               res = merge(res, lists[i]);
           }
           return res;
       }
       ListNode* merge(ListNode *l1, ListNode *l2)
       {
           ListNode *newHead = new ListNode(-1);
           ListNode *cur = newHead;
           while (l1 != NULL && l2 != NULL)
           {
               if (l1->val < l2->val)
               {
                   cur->next = l1;
                   l1 = l1->next;
               }
               else
               {
                   cur->next = l2;
                   l2 = l2->next;
               }
               cur = cur->next;
           }
           if (l1 != NULL)
           {
               cur->next = l1;
           }
           if (l2 != NULL)
           {
               cur->next = l2;
           }
           return newHead->next;
       }

2. 利用分治法，每次将两个相邻的合并，直到最后只剩一个，效率比朴素的方法一更高，因为少了很多次合并过程。

   ```CPP
   ListNode* mergeKLists(vector<ListNode*>& lists) {
           //分治法，每次都将相邻的两两合并，直到最后只剩一个。
           if (lists.size() == 0)
           {
               return NULL;
           }
           return merge(lists, 0, lists.size() - 1);
       }
       ListNode* merge(vector<ListNode*> &lists, int left, int right)
       {
           if (left == right)
           {
               return lists[left];
           }
           int mid = left + (right - left) / 2;
           ListNode *l1 = merge(lists, left, mid);
           ListNode *l2 = merge(lists, mid + 1, right);
           return merge(l1, l2);
       }
     ListNode* merge(ListNode *l1, ListNode *l2)
       {
           ListNode *newHead = new ListNode(-1);
           ListNode *cur = newHead;
           while (l1 != NULL && l2 != NULL)
           {
               if (l1->val < l2->val)
               {
                   cur->next = l1;
                   l1 = l1->next;
               }
               else
               {
                   cur->next = l2;
                   l2 = l2->next;
               }
               cur = cur->next;
           }
           if (l1 != NULL)
           {
               cur->next = l1;
           }
           if (l2 != NULL)
           {
               cur->next = l2;
           }
           return newHead->next;
       }
   ```

   

3. 每次取出最小元素然后删除更新，依次取出，不用n方的排序，用优先队列。

   ```CPP
   
   ListNode* mergeKLists(vector<ListNode*>& lists) {
       //每次都找到最小那个元素，然后把它放到新链表中。
       //用优先队列来找到最小的元素。
       if (lists.size() == 0)
       {
           return NULL;
       }
       ListNode *newHead = new ListNode(-1);
       ListNode *cur = newHead;
       priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> q;
       for (int i = 0; i < lists.size(); i++)
       {
           if (lists[i] != NULL)
           {
               q.push(make_pair(lists[i]->val, lists[i]));
           }
       }  
       while (!q.empty())
       {
           pair<int, ListNode*> temp = q.top();
           q.pop();
           cur->next = temp.second;
           cur = cur->next;
           if (temp.second->next != NULL)
           {
               q.push(make_pair(temp.second->next->val, temp.second->next));
           }
       }
       return newHead->next;
   }
   ```

   

## 35 LRU缓存

### 题目

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

### 解答

思路是用双向链表+哈希表。

双向链表的作用是存结点访问顺序。

对它的操作包括把某个结点摘下来，放到头结点处；删除尾节点后的结点（最后一个节点）；在头部插入一个节点。

哈希表用来判断是否有所需要的值,有的话直接取出使用。（因为取出的是一个DlistNode，所以它的前驱后继都在，可以直接用，而不是从头开始遍历判断）

```cpp
struct DListNode
{
    int val,key;
    DListNode *next;
    DListNode *pre;
    DListNode() : val(0),key(0), next(nullptr),pre(nullptr) {}
    DListNode(int x,int y) : key(x),val(y) ,next(nullptr),pre(nullptr) {}
};
class LRUCache {
private:
    int capacity;
    DListNode *head;
    DListNode *tail;
    unordered_map<int,DListNode*> mp;
public:
    LRUCache(int capacity) {
        this->capacity = capacity;
        head = new DListNode();
        tail = new DListNode();
        head->next = tail;
        tail->pre = head;
    }
    
    int get(int key) {
        if(mp.find(key) == mp.end()){
            return -1;
        }
        DListNode *node = mp[key];
        //删除节点
        node->pre->next = node->next;
        node->next->pre = node->pre;
        node->next = head->next;
        //将节点插入到头部
        head->next->pre = node;
        head->next = node;
        node->pre = head;
        return node->val;

    }
    
    void put(int key, int value) {
        if(mp.find(key) != mp.end()){//存在情况下，不用考虑容量问题
            DListNode *node = mp[key];
            node->val = value;
            //删除节点
            node->pre->next = node->next;
            node->next->pre = node->pre;
            node->next = head->next;
            //将节点插入到头部
            head->next->pre = node;
            head->next = node;
            node->pre = head;
        }else{
            DListNode *node = new DListNode(key,value);
            //将节点插入到头部
            mp[key] = node;
            node->next = head->next;
            head->next->pre = node;
            head->next = node;
            node->pre = head;
            //判断容量是否溢出，溢出的话需要删除尾部节点
            if(mp.size() > capacity){
                DListNode *del = tail->pre;
                del->pre->next = tail;
                tail->pre = del->pre;
                mp.erase(del->key);
                delete del;
            }
        }
    }

};struct DListNode
{
    int val,key;
    DListNode *next;
    DListNode *pre;
    DListNode() : val(0),key(0), next(nullptr),pre(nullptr) {}
    DListNode(int x,int y) : key(x),val(y) ,next(nullptr),pre(nullptr) {}
};
class LRUCache {
private:
    int capacity;
    DListNode *head;
    DListNode *tail;
    unordered_map<int,DListNode*> mp;
public:
    LRUCache(int capacity) {
        this->capacity = capacity;
        head = new DListNode();
        tail = new DListNode();
        head->next = tail;
        tail->pre = head;
    }
    
    int get(int key) {
        if(mp.find(key) == mp.end()){
            return -1;
        }
        DListNode *node = mp[key];
        //删除节点
        node->pre->next = node->next;
        node->next->pre = node->pre;
        node->next = head->next;
        //将节点插入到头部
        head->next->pre = node;
        head->next = node;
        node->pre = head;
        return node->val;

    }
    
    void put(int key, int value) {
        if(mp.find(key) != mp.end()){//存在情况下，不用考虑容量问题
            DListNode *node = mp[key];
            node->val = value;
            //删除节点
            node->pre->next = node->next;
            node->next->pre = node->pre;
            node->next = head->next;
            //将节点插入到头部
            head->next->pre = node;
            head->next = node;
            node->pre = head;
        }else{
            DListNode *node = new DListNode(key,value);
            //将节点插入到头部
            mp[key] = node;
            node->next = head->next;
            head->next->pre = node;
            head->next = node;
            node->pre = head;
            //判断容量是否溢出，溢出的话需要删除尾部节点
            if(mp.size() > capacity){
                DListNode *del = tail->pre;
                del->pre->next = tail;
                tail->pre = del->pre;
                mp.erase(del->key);
                delete del;
            }
        }
    }

};
```

## ？刷错了， 插入排序

### 题目

### 解答

就是课上讲的插入排序的代码实现，相比于只考虑过程，写出来还是有点麻烦的。

不过只要记得用prev来标记结点，让cur在插入后能够重新找到位置就可以了。

以及特判prev直接插入cur后面的情况，相当于对部分情况做了化简，能够提高效率。

```CPP
ListNode *insertionSortList(ListNode *head)
{
    // 不需要排的情况
    if (head == NULL || head->next == NULL)
    {
        return head;
    }
    ListNode *newHead = new ListNode(-1);
    newHead->next = head;
    ListNode *cur = head->next;
    ListNode *prev = head;
    while (cur != NULL)
    {
        if (cur->val >= prev->val)
        {//cur直接插入到prev后面
            prev = cur;
            cur = cur->next;
        }
        else
        {
            ListNode *temp = newHead;
            //temp用于从头开始遍历，找到cur应该插入的位置
            while (temp->next->val < cur->val)
            {
                temp = temp->next;
            }
            prev->next = cur->next;
            //prev指向cur的下一个节点，最后更新cur用于下一次循环
            //这里将cur插入到temp后面
            cur->next = temp->next;
            temp->next = cur;
            cur = prev->next;
        }
    }

    return newHead->next;
}

```

## 36 二叉树中序遍历

### 题目

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

### 解答

递归写法比较简单。

就直接：

> visit(左)
>
> visit（根）
>
> visit（右）

就可以。

```CPP
#include <bits/stdc++.h>
using namespace std;
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
vector<int> ans;
vector<int> inorderTraversal(TreeNode* root) {
    if(root==NULL){
        return ans;}
    inorderTraversal(root->left);
    ans.push_back(root->val);
    inorderTraversal(root->right);
    return ans;
    }
```

如果不递归的话，就得用栈了。

```CPP
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> ans;
    stack<TreeNode*> s;
    TreeNode* cur=root;
    while(cur!=NULL||!s.empty()){
        while(cur!=NULL){
            s.push(cur);
            cur=cur->left;
        }
        cur=s.top();
        s.pop();
        ans.push_back(cur->val);
        cur=cur->right;
    }
    return ans;
    }
```

## 37 二叉树最大深度

### 题目

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

### 解答

可以广度优先->层序遍历，用ans记录层数即可。

注意中间是借助队列，每次循环都是把头部的那一层push进去，然后pop size次，就可以结束一层，到下一层就+1.

```CPP
int maxDepth(TreeNode* root){
    if(root==NULL){
        return 0;
    }
    queue<TreeNode*> q;
    q.push(root);
    int ans=0;
    while(!q.empty()){
        int size=q.size();
        while(size--){
            TreeNode* cur=q.front();
            q.pop();
            //更新时注意要非空再push。
            if(cur->left!=NULL){
                q.push(cur->left);
            }
            if(cur->right!=NULL){
                q.push(cur->right);
            }
        }
        ans++;
    }
    return ans;
}
```

也可以深度优先：

对每个结点，最长深度都是左右结点最大深度+1，因此：

ans=max(maxdepth(root->left),maxdepth(root->right))+1.

写出来简洁美丽，太美妙了：

```CPP
    int maxDepth(TreeNode* root) {
        if(root==NULL)return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
```

## 38 翻转二叉树

### 题目

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

### 解答

用递归的方法，依次反转左右子树，终止条件是如果null就return null。

```CPP
TreeNode* invertTree(TreeNode* root) {
    if(root==NULL){
        return NULL;
    }
    TreeNode *left=invertTree(root->right);
     TreeNode *right=invertTree(root->left);
    root->left=left;
    root->right=right;
    return root;
    }
```

```CPP
TreeNode* invertTree(TreeNode* root) {
    if(root==NULL){
        return NULL;
    }
    invertTree(root->left);
    invertTree(root->right);
    swap(root->left,root->right);
    return root;
    }
```

## 39 对称二叉树

### 题目

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

### 解答

可以递归地检查左右子树是否一致。

检查内容是左边的点是否等于右边的。注意到“镜像对称”，应该是left->right=right->left这样。

```CPP
bool isSymmetric(TreeNode* root) {
    return check(root->left,root->right);
}
bool check(TreeNode* left,TreeNode* right){
    if(left==NULL && right==NULL){
        return true;
    }
    if(left==NULL || right==NULL){
        return false;
    }
    return (left->val==right->val) && check(left->left,right->right) && check(left->right,right->left);
}

```

也可以改为非递归的迭代。

用一个队列来存，每次取出相邻两个值来比较，如果不一样就return false，如果队列为空都没return，证明相同，return true。

```CPP
bool isSymmetric(TreeNode* root) {
    queue<TreeNode*> q;
    q.push(root->left);
    q.push(root->right);//这里也可以直接两个root，但是如果传left和right，少一次迭代，速度会更快。
    while(!q.empty()){
        TreeNode* Leftnode=q.front();
        q.pop();
        TreeNode* Rightnode=q.front();
        q.pop();
        if(Leftnode==NULL && Rightnode==NULL){
            continue;
        }
        if(Leftnode==NULL || Rightnode==NULL){
            return false;
        }
        if(Leftnode->val!=Rightnode->val){
            return false;
        }
        q.push(Leftnode->left);
        q.push(Rightnode->right);  
        //这里要注意一下顺序，对应关系。
        q.push(Leftnode->right);
        q.push(Rightnode->left);
    }
    return true;
}

```

## 40 二叉树的直径

### 题目

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

### 解答

递归遍历每一个点，然后找到以当前结点为“根节点”的最长路径的节点数：左最大+右最大+1.

递归遍历每一个点，每次都用max更新ans。

最后将得到的ans-1即可。（路径=经过节点数-1）

```CPP
int diameterOfBinaryTree(TreeNode* root) {
    int ans=0;
    depth(root,ans);
    return ans-1;
}
int depth(TreeNode* root,int& ans){
    if(root==NULL){
        return 0;
    }
    int left=depth(root->left,ans);
    int right=depth(root->right,ans);
    ans=max(ans,left+right+1);
    return max(left,right)+1;
}
```

如果不基于结点？

## 41 二叉树层序遍历

### 题目

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

### 解答

和`二叉树最大深度`那道题的层序遍历一样，借助一个队列就可以实现了。

```CPP
 vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> ans;
    if(root==NULL){
        return ans;
    }
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size=q.size();
        vector<int> level;
        for(int i=0;i<size;i++){
            TreeNode* node=q.front();
            q.pop();
            level.push_back(node->val);
            if(node->left!=NULL){
                q.push(node->left);
            }
            if(node->right!=NULL){
                q.push(node->right);
            }
        }
        ans.push_back(level);
    }
    return ans;
 }
```

## 42 将有序数组转为二叉搜索树

### 题目

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 的二叉树。

### 解答

要构造平衡二叉树，一个直观的想法是，根节点取数组中间的值，子树根节点也取子数组中间的值，由此递归而得。

具体证明参考[力扣1382. 将二叉搜索树变平衡 - 力扣（LeetCode）](https://leetcode.cn/problems/balance-a-binary-search-tree/solutions/241897/jiang-er-cha-sou-suo-shu-bian-ping-heng-by-leetcod/)

```CPP
TreeNode* sortedArrayToBST(vector<int>& nums) {
        return helper(nums,0,nums.size()-1);
    }
TreeNode* helper(vector<int>& nums,int left,int right){
    if(left>right){
        return NULL;
    }
    int mid=(left+right)/2;
    TreeNode* root=new TreeNode(nums[mid]);
    root->left=helper(nums,left,mid-1);
    root->right=helper(nums,mid+1,right);
    return root;
}
```

## 43 验证二叉搜索树

### 题目

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

### 解答

注意二叉搜索树要求的是，右子树全大于根节点。

所以以下这种方法是错误的：

```CPP
bool isValidBST(TreeNode* root) {
    return helper(root);
}
bool helper(TreeNode* root){
    if(root==NULL){
        return true;
    }
    if(root->left!=NULL && root->left->val>=root->val){
        return false;
    }
    if(root->right!=NULL && root->right->val<=root->val){
        return false;
    }
    return helper(root->left) && helper(root->right);
}
```

在递归搜索子树时没有保证大于根节点。

正确做法应该是：

在递归时记录上下界，左子树时用根节点更新上界，右子树时用根节点更新下界。

```CPP
public:
    bool isValidBST(TreeNode* root) {
    return helper(root,NULL,NULL);
}
bool helper(TreeNode* root,TreeNode* min,TreeNode* max){
    if(root==NULL){
        return true;
    }
    if(min!=NULL && root->val<=min->val){
        return false;
    }
    if(max!=NULL && root->val>=max->val){
        return false;
    }
    return helper(root->left,min,root) && helper(root->right,root,max);
}
```

此外，由于二叉搜索树中序递增，所以可以用中序遍历来判断。

```CPP
bool isValidBST(TreeNode* root) {
    stack<TreeNode*> s;
    TreeNode* pre=NULL;
    while(!s.empty() || root!=NULL){
        while(root!=NULL){
            s.push(root);
            root=root->left;
        }
        root=s.top();
        s.pop();
        if(pre!=NULL && pre->val>=root->val){
            return false;
        }
        pre=root;
        root=root->right;
    }
    return true;
}
```

## 44 二叉搜索树第k小元素

### 题目

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

### 解答

中序遍历，遍历到的第k个元素就是第k小。

```CPP
    int kthSmallest(TreeNode* root, int k) {
        int ans=0;
        stack<TreeNode*> s;
        while(!s.empty() || root!=NULL){
            while(root!=NULL){
                s.push(root);
                root=root->left;
            }
            root=s.top();
            s.pop();
            k--;
            if(k==0){
                ans=root->val;
                break;
            }
            root=root->right;
        }
        return ans;
    }
```

## 45 二叉树的右视图

### 题目

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

### 解答

直接层序遍历，每一层最右边的那个点就是所需要的点。

可以改为从右向左的（就是先将右子树push），那么直接输出每层的第一个就可以。

```CPP
vector<int> rightSideView(TreeNode* root) {
    vector<int> ans;
    if(root==NULL){
        return ans;
    }
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int n=q.size();
        for(int i=0;i<n;i++){
            TreeNode* temp=q.front();
            q.pop();
            if(i==0){
                ans.push_back(temp->val);
            }
            if(temp->right!=NULL){
                q.push(temp->right);
            }
            if(temp->left!=NULL){
            q.push(temp->left);
            }
        }
    }
    return ans;
}
```

## 46 先序展开链表

### 题目



### 解答

看到了超级牛逼的简单易懂的解法：

@[明知山有虎？](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/218689/114-er-cha-shu-zhan-kai-wei-lian-biao-by-ming-zhi-)

就是，整个过程相当于把子树改为：根节点->左子树展开->右子树展开。的一个递归过程。

```CPP
void flatten(TreeNode* root) {
    if(root==NULL){
        return;
    }
    //把左右子树编变成链表。
    flatten(root->left);
    flatten(root->right);
    //把根节点的左右子树都拿下来。
    TreeNode* left=root->left;
    TreeNode* right=root->right;
    //把左子树放到右边。
    root->left=NULL;
    root->right=left;
    //把原来的右子树放到现在的右子树的最后面。
    TreeNode* p=root;
    //找到现在的右子树的最右边结点。
    while(p->right!=NULL){
        p=p->right;
    }
    p->right=right;
    return;
}
```

当然，最好想的解法是：

前序遍历，用vecor存起来，然后再转成链表。

```CPP
void flatten(TreeNode* root) {
    if(root==NULL){
        return;
    }
    stack<TreeNode*> s;
    s.push(root);
    TreeNode* pre=NULL;
    while(!s.empty()){
        TreeNode* cur=s.top();
        s.pop();
        if(pre!=NULL){
            pre->left=NULL;
            pre->right=cur;
        }
         //先放右子树，再放左子树，这样左子树就会先出栈。
        TreeNode* left=cur->left;
        TreeNode* right=cur->right;
        if(right!=NULL){
            s.push(right);
        }
        if(left!=NULL){
            s.push(left);
        }
        pre=cur;
    }
    return;
}
```

## 47 从前序与中序构造二叉树

### 题目

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

### 解答

就是按照中序加先序的思路来实现，把王道上学的直接观察方式改为具体的代码。

实现细节主要注意一下递归的参数怎么传就可以。

```CPP
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    if(preorder.size()==0){
        return NULL;
    }
    TreeNode* root=new TreeNode(preorder[0]);
    int i=0;
    //找到根节点在中序遍历中的位置。
    for(;i<inorder.size();i++){
        if(inorder[i]==preorder[0]){
            break;
        }
    }
    //左子树的前序遍历。
    vector<int> left_preorder(preorder.begin()+1,preorder.begin()+i+1);
    vector<int> left_inorder(inorder.begin(),inorder.begin()+i);
    //右子树的前序遍历。
    vector<int> right_preorder(preorder.begin()+i+1,preorder.end());
    vector<int> right_inorder(inorder.begin()+i+1,inorder.end());
    //递归构建左右子树。
    root->left=buildTree(left_preorder,left_inorder);
    root->right=buildTree(right_preorder,right_inorder);
    return root;
}
```

## 48 路径总和 Ⅲ

### 题目

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

### 解答

直接搜索的方式，理论上能过。

但有两个逆天测试点，给干得overflow了，太抽象了点。于是需要一些改进措施。

```CPP
long long Sum(TreeNode* root, int targetSum) {
    if(root==NULL){
        return 0;
    }
    int res=0;
    if(root->val==targetSum){
        res++;
    }
    res+=Sum(root->left,targetSum-root->val);
    res+=Sum(root->right,targetSum-root->val);
    return res;
}
int ans=0;
int pathSum(TreeNode* root, int targetSum) {
    if(root==NULL){
        return 0;
    }
     if(root->val==1000000000){
         //为了应对抽象的测试点，出此下策
        return 0;
    }
    ans+=Sum(root,targetSum);
    pathSum(root->left,targetSum);
    pathSum(root->right,targetSum);
}

```

但有一说一我真不觉得官方解法和我的有什么大区别）

```CPP

    
int rootSum(TreeNode* root, long targetSum) {
        if (!root) {
            return 0;
        }

        int ret = 0;
        if (root->val == targetSum) {
            ret++;
        } 

        ret += rootSum(root->left, targetSum - root->val);
        ret += rootSum(root->right, targetSum - root->val);
        return ret;
    }

    int pathSum(TreeNode* root, int targetSum) {
        if (!root) {
            return 0;
        }
        
        int ret = rootSum(root, targetSum);
        ret += pathSum(root->left, targetSum);
        ret += pathSum(root->right, targetSum);
        return ret;
    }
};
```

还有前缀和解法，这次不想看。

## 49 最近公共祖先

### 题目

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”



### 解答

分两种情况：

1. 一个结点的左子树有p或q，右子树有q或p，此时它一定是公共节点。
2. 一个节点本身就是p或q，它的子孙是q或p，此时它自己就是公共节点。

```CPP
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root){
            return NULL;
        }
        if(root==p||root==q){
            //由于保证了一定有公共祖先，所以如果root==p或者root==q，那么root就是最近公共祖先。
            return root;
        }
        //递归寻找左右子树是否有结点。
        TreeNode* left=lowestCommonAncestor(root->left,p,q);
        TreeNode* right=lowestCommonAncestor(root->right,p,q);
        //如果左右子树都有结点，那么root就是最近公共祖先。
        if(left&&right){
            return root;
        }
        if(left){
            return left;
        }
        if(right){
            return right;
        }
        //如果左右子树都没有结点，那么返回NULL。
        return NULL;
    }

```

如果当作满二叉树，用vector的话，可能会有爆炸的数据。

## 50 二叉树中的最大路径和

### 题目

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

### 解答

我们可以依次搜索每个节点，求出以任意结点作为根节点情况下的最大值，这肯定能包括所需要求的最大值。

在求的过程中如何更新？

假设以i为根节点，对应的最大值应该为：

max(left,0)+max(right,0)+i.val。

为什么？如果值比0大，证明加上对应子树能够使得路径增长，但如果比0小，就证明不需要那边的子树路径。

由此从下往上递归更新，就可以得到最终的结果，终止条件是null->return 0。

```CPP
int maxSum=INT_MIN;
int dfs(TreeNode* root){
        if(!root){
            return 0;
        }
        
        int left=max(0,dfs(root->left));
        int right=max(0,dfs(root->right));
        maxSum=max(maxSum,left+right+root->val);
        return max(left,right)+root->val;
}
int maxPathSum(TreeNode* root) {
    dfs(root);
    return maxSum;
}
/*stl还有函数模板类，能这样写，就不用定义全局变量了学一下：
    int maxSum=INT_MIN;
    function<int(TreeNode*)> dfs=[&](TreeNode* root){
        if(!root){
            return 0;
        }
        int left=max(0,dfs(root->left));
        int right=max(0,dfs(root->right));
        maxSum=max(maxSum,left+right+root->val);
        return max(left,right)+root->val;
    };
    dfs(root);
    return maxSum;
*/

```

## 51 岛屿数量

### 题目

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

### 解答

这可太熟悉了。

就直接遍历，然后dfs把遇到的陆地全部变成水就可以了。

```CPP
void dfs(vector<vector<char>>& grid,int i,int j){
    if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]=='0'){
        return;
    }
    grid[i][j]='0';
    //可以把返回判断放在下面，if（）然后再dfs，也可以直接啥都不管dfs，在前面进行判断。
    dfs(grid,i+1,j);
    dfs(grid,i-1,j);
    dfs(grid,i,j+1);
    dfs(grid,i,j-1);
}
int numIslands(vector<vector<char>>& grid) {
    int ans=0;//最开始忘记初始化一直过不了，真是无语。
    for(int i=0;i<grid.size();i++){
        for(int j=0;j<grid[0].size();j++){
            if(grid[i][j]=='1'){
                ans++;
                dfs(grid,i,j);
            }
        }
    }
    return ans;
}
```

## 52 腐烂的橘子

### 题目

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。

### 解答

用BFS，因为每个橘子可以感染周边的四个，所以其实类似于BFS的过程。

我们可以先扫一遍，把所有的好橘子都存在队列里，然后依次感染。上下左右的橘子。

记录下size，每次都把size个出队，每size个为一轮，经过一轮就++。

到最后队列空了就再扫描一遍，如果还有新鲜橘子，就return-1了，证明有无法被感染的。

```CPP
int orangesRotting(vector<vector<int>>& grid) {
    int ans=0;
    int m=grid.size();
    int n=grid[0].size();
    queue<pair<int,int>> q;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(grid[i][j]==2){
                q.push({i,j});
            }
        }
    }
    while(!q.empty()){
        int size=q.size();
        for(int i=0;i<size;i++){
            pair<int,int> p=q.front();
            q.pop();
            int x=p.first;
            int y=p.second;
            if(x-1>=0&&grid[x-1][y]==1){
                grid[x-1][y]=2;
                q.push({x-1,y});
            }
            if(x+1<m&&grid[x+1][y]==1){
                grid[x+1][y]=2;
                q.push({x+1,y});
            }
            if(y-1>=0&&grid[x][y-1]==1){
                grid[x][y-1]=2;
                q.push({x,y-1});
            }
            if(y+1<n&&grid[x][y+1]==1){
                grid[x][y+1]=2;
                q.push({x,y+1});
            }
        }
        if(!q.empty()){
            ans++;
        }
    }
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(grid[i][j]==1){
                return -1;
            }
        }
    }
    return ans;
}

```



## 53 课程表

### 题目

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

### 解答

一眼拓扑排序,只是如何实现稍微有点麻烦，需要对输入数据进行一下处理：用入度表来存每个结点的入度，如果为0的话，就可以入队，否则要等更新。

更新时利用图，把当前节点的所有出边的结点的数据全部--。

```CPP
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    //拓扑排序
    vector<vector<int>> graph(numCourses);
    vector<int> indegree(numCourses);
    for(auto& p:prerequisites){
        //prerequisites[i][1]是prerequisites[i][0]的先修课程。且题目保证了pre只有两个元素。
        graph[p[1]].push_back(p[0]);
        indegree[p[0]]++;
    }
    queue<int> q;
    for(int i=0;i<numCourses;i++){//把所有入度为0的结点入队。
        if(indegree[i]==0){
            q.push(i);
        }
    }
    while(!q.empty()){
        int cur=q.front();
        q.pop();
        numCourses--;
        //遍历cur的所有后继结点，把它们的入度减1。
        for(auto& next:graph[cur]){//遍历cur的所有后继结点。
            if(--indegree[next]==0){//如果next的入度为0，那么next可以入队。
                q.push(next);
            }
        }
    }
    return numCourses==0;
}
```

不能形成拓扑排序，也就是有环，那么也可以用DFS。

## 54 实现Trie 前缀树

### 题目

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

### 解答

就搞一个26叉树（题目说数据只有26个小写字母），一一对应。

对每一个点，可以设置为26个元素的vector，然后内部用一个bool标记是否是一个单词的结尾。

这种用类来写的还有点不太熟有一说一。

```CPP
class Trie {
public:
    vector<Trie*> children;
    bool isEnd;
    Trie() : children(26),isEnd(false){}
    
    void insert(string word) {
        Trie* node = this;
        for(char c : word){
            if(node->children[c-'a'] == nullptr){
                node->children[c-'a'] = new Trie();
            }
            node = node->children[c-'a'];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        Trie* node = this;
        for(char c : word){
            node = node->children[c-'a'];
            if(node == nullptr){
                return false;
            }
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        Trie* node = this;
        for(char c : prefix){
            node = node->children[c-'a'];
            if(node == nullptr){
                return false;
            }
        }
        return true;

    }
};
```

## 55 全排列

### 题目

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

### 解答

回溯，dfs的思路，除了使用一个存当前path的vector外，还对应着需要一个bool变量标志是否已经被使用。

```cpp
vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> res;
    vector<int> path;//用来存储路径。
    vector<bool> used(nums.size(),false);//用来标记nums中的数是否被用过。
    //这里用到了lambda表达式，相当于定义了一个函数，这个函数的名字是dfs。
    function<void()> dfs = [&](){
        //dfs函数的功能是：把nums中的数全排列，然后把结果存储到res中。
        if(path.size() == nums.size()){//如果path中的数的个数等于nums中的数的个数，那么就把path加入到res中。
            res.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i++){
            if(used[i]){
                //如果这个数已经被用过了，那么就跳过。
                continue;
            }
            //如果这个数没有被用过，那么就把它加入到path中，然后标记为已经用过。
            path.push_back(nums[i]);
            used[i] = true;
            dfs();
            //回溯，把这个数从path中弹出，然后标记为没有用过。
            path.pop_back();
            used[i] = false;
        }
    };
    dfs();
    return res;
}
```

## 56 子集

### 题目

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

### 解答

还是dfs，就是从第一个数字开始，然后第二个，依次进入各个数字得到答案。

当然，最后要记得pop。

```CPP
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> res;
    vector<int> path;
    function<void(int)> dfs = [&](int start){
        res.push_back(path);
        for(int i = start; i < nums.size(); i++){
            path.push_back(nums[i]);
            dfs(i+1);
            path.pop_back();
        }
    };
    dfs(0);
    return res;
}
```

## 57 电话号码的字母组合

### 题目

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

### 解答

思路和全排列差不多，只是dfs退出条件要改为有n个数字。

相当于输出n个数的全排列，只是有些数字会对应三个值，都要添加进去？

为了更好地实现这个，把dfs放进了循环中。对应每个数字对应的那几个字母。

```CPP
    vector<string> letterCombinations(string digits) {
        vector<string> res;
        if(digits.empty()){
            return res;
        }
        //dict[i]表示数字i对应的字母。
        vector<string> dict={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        string path;
        function<void(int)> dfs = [&](int start){
            if(path.size() == digits.size()){
                //如果path中的字母的个数等于digits中的数字的个数，那么就把path加入到res中。
                res.push_back(path);
                return;
            }
            for(int i = start; i < digits.size(); i++){
                //遍历digits中的数字。
                for(char c : dict[digits[i]-'0']){
                    //遍历数字i对应的字母。
                    path.push_back(c);
                    dfs(i+1);
                    path.pop_back();
                }
            }
        };
        dfs(0);//dfs从0开始。
        return res;
    }

```

## 58 组合总和

### 题目

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

### 解答

还是用dfs，和57差不多，但在dfs时把`i+1`换成`i`，就可以。

```CPP
vector<vector<int>> combinationSum(vector<int> &candidates, int target)
{
    vector<vector<int>> res;
    if (candidates.empty())
    {
        return res;
    }
    vector<int> path;
    function<void(int, int)> dfs = [&](int start, int target)
    {
        if (target == 0)
        {
            res.push_back(path);
            return;
        }
        for (int i = start; i < candidates.size(); i++)
        {
            if (target - candidates[i] >= 0)
            {
                path.push_back(candidates[i]);
                dfs(i, target - candidates[i]);
                path.pop_back();
            }
        }
    };
    dfs(0, target);
    return res;
}
```

## 59 括号生成

### 题目

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

### 解答

有点难，主要是可能想不到分为两个参数的`dfs`。

当然，考虑到需要补左括号和右括号，也是有迹可循的。

当括号全用完时，是一个新答案，`push`。

当括号没用完时，先放左再放右，每放一个就走一次`dfs`，走完之后记得删掉刚放的那个。

```CPP
 vector<string> generateParenthesis(int n) {
        vector<string> res;
        if(n == 0){
            return res;
        }
        string path;
        function<void(int, int)> dfs = [&](int left, int right){
            //left表示左括号的个数，right表示右括号的个数。
            //都为0时，说明左右括号都用完了，此时把path加入到res中。
            if(left == 0 && right == 0){
                res.push_back(path);
                return;
            }
            if(left > 0){
                //如果左括号的个数大于0，那么就还可以放置左括号。
                path.push_back('(');
                dfs(left-1, right);
                //记得把path中的左括号弹出来，因为path是全局变量，后面还要用。
                path.pop_back();
            }
            if(right > left){
                //如果右括号的个数大于左括号的个数，那么就还可以放置右括号。
                path.push_back(')');
                dfs(left, right-1);
                path.pop_back();
            }
        };
        dfs(n, n);
        return res;
    }

```

## 60 单词搜索

### 题目

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

### 解答

我们知道主函数肯定是遍历格子，作为dfs的初始位置。

如果等于word[0]，那么就进入dfs，否则就下一个位置。

如果遍历完所有点都未成功，就返回false。

在每个`dfs`内部，由于可以往上下左右四个方向搜索，所以需要一个备用数组`visited`，来判断是否是已经访问过的结点（否则有可能死循环）。

对于visited，每走到一个位置都应该标记为`true`,在退出后重置为`false`。

```CPP
bool exist(vector<vector<char>>& board, string word) {
    int m = board.size();
    int n = board[0].size();
    vector<vector<bool>> visited(m, vector<bool>(n, false));
    function<bool(int, int, int)> dfs = [&](int i, int j, int k){
        if(i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || board[i][j] != word[k]){
            return false;
        }
        if(k == word.size()-1){
            return true;
        }
        visited[i][j] = true;
        bool res = dfs(i+1, j, k+1) || dfs(i-1, j, k+1) || dfs(i, j+1, k+1) || dfs(i, j-1, k+1);
        visited[i][j] = false;
        return res;
    };
    for(int i = 0; i < m; i++){
        for(int j = 0; j < n; j++){
            if(dfs(i, j, 0)){
                return true;
            }
        }
    }
    return false;
}
```

## 61 分割回文串

### 题目

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

### 解答

首先，返回的是x个由s分隔而成的字串。

我们单独写一个函数来判断，一个字串是否是回文串。

`dfs`从0开始，终止条件是开始位置为`s.size()`，此时整个子串已经被分割完毕。

而每一层的内部，都应该是从start位置开始，判断从start开始，后面能否有个位置使之构成回文串，如果有的话，把当前这一段加入答案中，然后再往后dfs。

dfs结束后要把path恢复，里面装的是目前的一个分割状态，退出时依次把里面的东西吐出来。

```CPP
bool isPalindrome(string s, int start, int end)
{
    while (start < end)//不带等号。
    {
        if (s[start++] != s[end--])
        {
            return false;
        }
    }
    return true;
}
vector<vector<string>> partition(string s) {
    vector<vector<string>> res;
    //返回的答案是x个s的分割。
    if (s.empty())
    {
        return res;
    }
    vector<string> path;
    function<void(int)> dfs = [&](int start)
    {
        if (start == s.size())//终止条件，如果start等于s.size()，说明已经遍历完了。
        {
            res.push_back(path);
            return;
        }
        for (int i = start; i < s.size(); i++)//
        {
            if (isPalindrome(s, start, i))//start==i时，s[start...i]只有一个字符，也是回文串。
            {//如果s[start...i]是回文串，那么就把s[start...i]加入到path中。
                path.push_back(s.substr(start, i - start + 1));
                //然后从i+1开始继续dfs。
                dfs(i + 1);
                //记得把path中的s[start...i]弹出来，因为path是全局变量，后面还要用。
                path.pop_back();
            }
        }
    };
    dfs(0);
    return res;
}
```

## 62 N皇后

### 题目

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

### 解答

太典了。

反正就是按照层的顺序依次放置皇后。

如果放了n个且没冲突就可以返回一组答案。

否则，证明这个组不行，return到上一层，换一个位置放。

判断冲突时要注意，由于我们从上往下放的，那么判断是否冲突只用搜索上面几层，之后的层因为都没有放置所以肯定不用搜索。

```CPP
bool isValid(vector<string> &board, int row, int col)
{
    int n = board.size();
    for (int i = 0; i < row; i++)
    {
        if (board[i][col] == 'Q')
        {
            return false;
        }
    }
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
    {
        if (board[i][j] == 'Q')
        {
            return false;
        }
    }
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)
    {
        if (board[i][j] == 'Q')
        {
            return false;
        }
    }
    return true;
}
vector<vector<string>> solveNQueens(int n) {//dfs版本
    vector<vector<string>> res;
    vector<string> board(n, string(n, '.'));
    function<void(int)> dfs = [&](int row)
    {
        if (row == n)
        {
            res.push_back(board);
            return;
        }
        for (int col = 0; col < n; col++)
        {
            if (isValid(board, row, col))
            {
                board[row][col] = 'Q';
                dfs(row + 1);
                board[row][col] = '.';
            }
        }
    };
    dfs(0);
    return res;
    }
```

## 63 搜索插入

### 题目

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

### 解答

就很简单的二分搜索就可以了。

一个`left`和一个`right`。

`mid`就(`left`+`right`)/2。更新的时候别忘了是mid+1或-1，不是直接mid。

```CPP
int searchInsert(vector<int>& nums, int target) {
    int n = nums.size();
    int left = 0, right = n - 1;
    while (left <= right)
    {
        int mid = (left + right) / 2;
        if (nums[mid] == target)
        {
            return mid;
        }
        else if (nums[mid] < target)
        {
            left = mid + 1;
        }
        else if (nums[mid] > target)
        {
            right = mid - 1;
        }
    }
    return left;
}
```

## 64 搜索二维矩阵

### 题目

给你一个满足下述两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

### 解答

用上一题的思路，把它转成类似一维的。

变成从0到`mn-1`。

然后二分。

重要的是求了mid之后要把它转为矩阵对应位置

```CPP
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m = matrix.size();
    int n = matrix[0].size();
    int left = 0, right = m * n - 1;
    while (left <= right)
    {
        int mid = (left + right) / 2;
        //把mid转为矩阵对应位置。
        //有没有可能直接用指针？
        int row = mid / n;
        int col = mid % n;
        if (matrix[row][col] == target)
        {
            return true;
        }
        else if (matrix[row][col] < target)
        {
            left = mid + 1;
        }
        else if (matrix[row][col] > target)
        {
            right = mid - 1;
        }
    }
    return false;
}
```

这个有个问题，就是每一行的数据数量都得相同，如果不同就没法用了（mid对应位置求不出来）。

还有个新方法是：

先对行进行二分查找，找到第一个元素不大于它的最后一行，（就是对第一列的元素二分查）。

然后再对那一列来进行二分查看能否找到。

```CPP
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m = matrix.size();
    int n = matrix[0].size();
    int row = 0, col = n - 1;
    while (row < m && col >= 0)
    {
        if (matrix[row][col] == target)
        {
            return true;
        }
        else if (matrix[row][col] < target)
        {
            row++;
        }
        else if (matrix[row][col] > target)
        {
            col--;
        }
    }
    return false;
}
```

## 65 在排序数组中查找元素第一个和最后一个位置

### 题目

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

### 解答

首先想到，先二分法找到，然后依次左右边界扩大，找到对应的开始和结束下标。

```CPP
vector<int> searchRange(vector<int>& nums, int target) {
    int n = nums.size();
    int left = 0, right = n - 1;
    while (left <= right)
    {
        int mid = (left + right) / 2;
        if (nums[mid] == target)
        {
            int i = mid, j = mid;
            while (i >= 0 && nums[i] == target)
            {
                i--;
            }
            while (j < n && nums[j] == target)
            {
                j++;
            }
            return {i + 1, j - 1};
        }
        else if (nums[mid] < target)
        {
            left = mid + 1;
        }
        else if (nums[mid] > target)
        {
            right = mid - 1;
        }
    }
    return {-1, -1};
}
```



但这在面对数组全为target时可能会超时，所以说整不成。

那么我们可以改成查找第一个大于它的下标和最后一个小于它的下标的方式。

```CPP
vector<int> searchRange(vector<int>& nums, int target) {
    if(nums.empty()) return {-1, -1};
    int n = nums.size();    
    int left = 0, right = n - 1;
    while (left < right)//找左边界
    {//这里不能用left<=right，因为如果用left<=right，那么当nums[mid]==target时，right=mid-1，会导致left=right=mid，从而死循环.
        int mid = (left + right) / 2;
        if (nums[mid] < target)
        {
            left = mid + 1;
        }
        else if (nums[mid] >= target)
        {
            right = mid;
        }
    }
    int start = left;
    if (nums[start] != target)
    {
        return {-1, -1};
    }
    left = 0, right = n - 1;
    while (left < right)//找右边界
    {
        int mid = (left + right + 1) / 2;//这里+1是为了避免死循环
        if (nums[mid] <= target)
        {
            left = mid;
        }
        else if (nums[mid] > target)
        {
            right = mid - 1;
        }
    }
    int end = left;
    return {start, end};
}
```

## 66 搜索旋转数组

### 题目

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

### 解答

想法是先找到旋转点的位置。

怎么找？旋转点对应的数字应该是所有数据中的最小值，用二分法缩小范围很快就能找到对应的位置。

然后通过和target比较，判断它应该在左区间还是右区间，再普通二分法找就可以了，找不到就return-1.

```CPP
int search(vector<int>& nums, int target) {
    if(nums.empty()) return -1;
    int n = nums.size();
    int left = 0, right = n - 1;
    //找到最小值的下标，也就是旋转点。
    while (left < right)
    {
        int mid = (left + right) / 2;
        if (nums[mid] < nums[right])
        {
            right = mid;
        }
        else if (nums[mid] > nums[right])
        {
            left = mid + 1;
        }
    }
    //此时left==right，即left为最小值的下标
    int start = left;
    //接下来就是普通的二分查找，看target在哪个区间
    if (target <= nums[n - 1])
    {
        left = start, right = n - 1;
    }
    else if (target > nums[n - 1])
    {
        left = 0, right = start - 1;
    }
    while (left <= right)
    {
        int mid = (left + right) / 2;
        if (nums[mid] == target)
        {
            return mid;
        }
        else if (nums[mid] < target)
        {
            left = mid + 1;
        }
        else if (nums[mid] > target)
        {
            right = mid - 1;
        }
    }
    return -1;
}
```

## 67 寻找旋转排序数组中的最小值

### 题目

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

### 解答

上一题的丐版？

就直接，把上一题的前半段解答，寻找`k`的过程复制过来就可以。

旋转对应的位置一定是最小值。

```CPP
int findMin(vector<int>& nums) {
  if(nums.empty()) return -1;
    int n = nums.size();
    int left = 0, right = n - 1;
    //找到最小值的下标，也就是旋转点。
    while (left < right)
    {
        int mid = (left + right) / 2;
        if (nums[mid] < nums[right])
        {
            right = mid;
        }
        else if (nums[mid] > nums[right])
        {
            left = mid + 1;
        }
        //不考虑nums[mid]==nums[right]的情况，因为题目说了数组中不包含重复元素。
    }
    //此时left==right，即left为最小值的下标
    return nums[left];
    }
```

## 68 寻找两个正序数组的中位数

### 题目

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

### 解答

如果没有复杂度限制，直接o（m+n）非常好想。

但由于有限制，所以考虑要二分法。

使用一个小trick，可以避免讨论奇偶：

> 我们分别找第 (m+n+1)/2个数，和(m+n+2)/2个数，然后求其平均值即可， 这对奇偶数均适用。假如 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。

看不懂，直接抄了：

```CPP
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int n1 = nums1.size(), n2 = nums2.size();
    if (n1 > n2)
    {
        return findMedianSortedArrays(nums2, nums1);
    }
    int left = 0, right = n1;
    while (left <= right)
    {
        int i = (left + right) / 2;
        int j = (n1 + n2 + 1) / 2 - i;//-i是为了保证i+j=(n1+n2+1)/2，也就是左半部分的元素个数等于右半部分的元素个数。
        //首先要保证i和j不会越界
        //其次要保证nums1[i-1]<=nums2[j] && nums2[j-1]<=nums1[i]，
        //这是为了保证左半部分的所有元素都小于右半部分的所有元素
        if (i < n1 && nums2[j - 1] > nums1[i])
        //这里是二分，i是短数组的下标，j是长数组的下标。
        //每次更新时，都是更新短数组的下标，且二分了（由i的定义可知）。
        //最后得到的结果是，i和j分别是短数组和长数组的分割点，使得对两个数组来说
        //左半部分的元素个数等于右半部分的元素个数，且左半部分的所有元素都小于右半部分的所有元素。
        //这样就可以直接求中位数了。
        {
            left = i + 1;
        }
        else if (i > 0 && nums1[i - 1] > nums2[j])
        {
            right = i - 1;
        }
        else
        {
            int maxLeft = 0;
            if (i == 0)
            {
                maxLeft = nums2[j - 1];
            }
            else if (j == 0)
            {
                maxLeft = nums1[i - 1];
            }
            else
            {
                maxLeft = max(nums1[i - 1], nums2[j - 1]);
            }
            if ((n1 + n2) % 2 == 1)//如果总元素个数为奇数，那么中位数就是左半部分的最大值
            {
                return maxLeft;
            }
            int minRight = 0;
            if (i == n1)
            {
                minRight = nums2[j];
            }
            else if (j == n2)
            {
                minRight = nums1[i];
            }
            else
            {
                minRight = min(nums1[i], nums2[j]);
            }
            return (maxLeft + minRight) / 2.0;
        }
    }
    return 0.0;
}
```

## 69 有效的括号

### 题目

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

### 解答

简单到我都会写，就不知道怎么写了？

大概有两个要注意的的点：

1. 如果是奇数个符号，那么肯定不能完全匹配，所以可以直接return false。
2. 如果在遍历s的过程中，栈空了，证明有无法匹配的右括号，也要return false。(意思是说除了左类型≠右类型之外，还有可能是有右无左)

```CPP
  bool isValid(string s) {
        stack<char> st;
        if (s.size() % 2 == 1)
        {
            return false;
        }
        for (char c : s)
        {
            if (c == '(' || c == '[' || c == '{')
            {
                st.push(c);
            }
            else
            {
                if (st.empty())//证明右括号多了
                {
                    return false;
                }
                if (c == ')' && st.top() != '(')
                {
                    return false;
                }
                if (c == ']' && st.top() != '[')
                {
                    return false;
                }
                if (c == '}' && st.top() != '{')
                {
                    return false;
                }
                st.pop();
            }
        }
        return st.empty();
    }
};
```

## 70 最小栈

### 题目

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

### 解答

有很多解答，首先可以是用辅助栈，普通栈就直接存，辅助栈存当前最小值，每次push的时候都进行比较，比当前最小值小或等于就入栈。每次pop时也比较，如果pop的值等于最小值就出栈。

```CPP
class MinStack {
private:
    stack<int> st;
    stack<int> min_st;
public:
    MinStack() {
        min_st.push(INT_MAX);
    }
    
    void push(int val) {
        st.push(val);
        if (min_st.empty() || val <= min_st.top())
        {
            min_st.push(val);
        }
    }
    
    void pop() {
        if (st.top() == min_st.top())
        {
            min_st.pop();
        }
        st.pop();

    }
    
    int top() {
        return st.top();

    }
    
    int getMin() {
        return min_st.top();
    }
};
```

也可以就用一个栈，每次push和pop都进行两次，一个是入栈元素，一个是当前最小值。

这样理论上并没有节省空间。（甚至由于每次都是push2次，空间用的反而多了）但可能由于stack实现的原因，反而会优化一些。

还有一种是不用辅助站，保存和min的差值的方法，但需要考虑溢出问题。

暂时不太想看，因为没太看懂，贴一个`java`代码：

```java
class MinStack {
    // 记录每个元素与【未压入】该元素时栈中最小元素的差值
    LinkedList<Long> stack;
    // 当前【已压入】栈中元素的最小值
    private long min;
    public MinStack() {
        stack = new LinkedList();
    }
    
    public void push(int val) {
        // 压入第一个元素
        if(stack.isEmpty()){
            min = val;
            stack.addFirst(0L);
            return;
        }
        // 栈不为空时，每次压入计算与min的差值后压入结果
        stack.push((long)val-min);
        // 更新min
        min = Math.min((long)val,min);
        // 上面两个语句是不能颠倒的！一定是先压入，在更新，因为min一定是当前栈中的最小值
    }
    
    public void pop() {
        long pop = stack.removeFirst();
        // 当弹出元素小于0时，说明弹出元素是当前栈中的最小值，要更新最小值
        if(pop<0){
            // 因为对于当前弹出的元素而言，计算压入栈中的值时，计算的是该元素与【未压入】该元素时
            // 栈中元素的最小值的差值，故弹出该元素后栈中的最小值就是未压入该元素时的最小值
            // 即当前元素的值（min）减去两者的差值
            long lastMin = min;
            min = lastMin - pop;
        }
        // 若大于等于0，不会对min有影响
    }
    
    public int top() {
        long peek = stack.peek();
        // 若当前栈顶小于等于0，说明最小值就是栈顶元素
        if(peek<=0) return (int)min;
        // 否则就是min+peek
        return (int)(min+peek);
    }
    
    public int getMin() {
        return (int)min;
    }
}
```

## ？

```
LOAD -o file:///home/baijy/opt/pixels/data/tcph/100g/customer -s tpch -t customer -n 319150 -r \| -c 1

```

```sql
-- Run the following statements in Presto/Trino to create the Pixels database for TPC-H

CREATE SCHEMA IF NOT EXISTS tpch;

USE tpch;

CREATE TABLE IF NOT EXISTS customer (
  c_custkey bigint,
  c_name varchar(25),
  c_address varchar(40),
  c_nationkey bigint,
  c_phone char(15),
  c_acctbal decimal(15,2),
  c_mktsegment char(10),
  c_comment varchar(117)
) WITH (storage='file', paths='/home/baijy/opt/pixels/data/tcph/customer/');

CREATE TABLE IF NOT EXISTS lineitem (
  l_orderkey bigint,
  l_partkey bigint,
  l_suppkey bigint,
  l_linenumber integer,
  l_quantity decimal(15,2),
  l_extendedprice decimal(15,2),
  l_discount decimal(15,2),
  l_tax decimal(15,2),
  l_returnflag char(1),
  l_linestatus char(1),
  l_shipdate date,
  l_commitdate date,
  l_receiptdate date,
  l_shipinstruct char(25),
  l_shipmode char(10),
  l_comment varchar(44)
) WITH (storage='file', paths='/home/baijy/opt/pixels/data/tcph/lineitem/');

CREATE TABLE IF NOT EXISTS nation (
  n_nationkey bigint,
  n_name char(25),
  n_regionkey bigint,
  n_comment varchar(152)
) WITH (storage='file', paths='/home/baijy/opt/pixels/data/tcph/nation/');

CREATE TABLE IF NOT EXISTS orders (
  o_orderkey bigint,
  o_custkey bigint,
  o_orderstatus char(1),
  o_totalprice decimal(15,2),
  o_orderdate date,
  o_orderpriority char(15),
  o_clerk char(15),
  o_shippriority integer,
  o_comment varchar(79)
) WITH (storage='file', paths='/home/baijy/opt/pixels/data/tcph/orders/');

CREATE TABLE IF NOT EXISTS part (
  p_partkey bigint,
  p_name varchar(55),
  p_mfgr char(25),
  p_brand char(10),
  p_type varchar(25),
  p_size integer,
  p_container char(10),
  p_retailprice decimal(15,2),
  p_comment varchar(23)
) WITH (storage='file', paths='/home/baijy/opt/pixels/data/tcph/part/');

CREATE TABLE IF NOT EXISTS partsupp (
  ps_partkey bigint,
  ps_suppkey bigint,
  ps_availqty integer,
  ps_supplycost decimal(15,2),
  ps_comment varchar(199)
) WITH (storage='file', paths='/home/baijy/opt/pixels/data/tcph/partsupp/');

CREATE TABLE IF NOT EXISTS region (
  r_regionkey bigint,
  r_name char(25),
  r_comment varchar(152)
) WITH (storage='file', paths='/home/baijy/opt/pixels/data/tcph/region/');

CREATE TABLE IF NOT EXISTS supplier (
  s_suppkey bigint,
  s_name char(25),
  s_address varchar(40),
  s_nationkey bigint,
  s_phone char(15),
  s_acctbal decimal(15,2),
  s_comment varchar(101)
) WITH (storage='file', paths='/home/baijy/opt/pixels/data/tcph/supplier/');
```

## 71 字符串解码

### 题目

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

### 解答

感觉没什么？

就是因为有括号匹配，所以可以用栈操作。

但也可以不用栈遇到`[`的时候进入循环处理直到`]`。

```CPP
string decodeString(string s) {
    int num=0;
    string res = "";
    string temp;
    int i = 0;
    while(i < s.size()){
        if(s[i] >= '0' && s[i] <= '9'){
            num = num * 10 + s[i] - '0';
        }
        else if(s[i] == '['){
            int j = i + 1;
            int cnt = 1;
            while(cnt != 0){
                if(s[j] == '[') cnt++;
                else if(s[j] == ']') cnt--;
                j++;
            }
            temp = decodeString(s.substr(i + 1, j - i - 2));
            for(int k = 0; k < num; k++){
                res += temp;
            }
            num = 0;
            i = j - 1;
        }
        else{
            res += s[i];
        }
        i++;
    
    }
    return res;}
```

## 72 每日温度

### 题目

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

### 解答

首先把answer数组初始化为1，然后用一个stack来辅助。

stack里面存的是尚未找到后继比它大的对应的天数。

当遍历到下一天时，会依次用栈顶元素（天数）对应的temp和当前循环遍历到的天数i进行对比。

然后依次出栈直到不大于。

在遍历结束返回答案时，栈可能不为空，但并不影响。(栈内元素对应为的答案为0，如果初始化时没有赋值，也可以在这里来赋值为0.)

```CPP
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> res(temperatures.size(), 0);
        stack<int> st;
        for(int i = 0; i < temperatures.size(); i++){
            while(!st.empty() && temperatures[i] > temperatures[st.top()]){
                res[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);
        }
        return res;
    }
```

## 73 *柱状图中最大的矩形

### 题目

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

### 解答

我操，看不懂，先放个答案在这里。

```CPP
#include <bits/stdc++.h>
using namespace std;
    int largestRectangleArea(vector<int>& heights) {
        int res = 0;
        stack<int> st;//we use stack to store the index of the elements in heights
        //which are in ascending order. by doing this, we can calculate the area of the rectangle with
        //heights[i] as the height, and the width is the distance between heights[i] and the previous element
        heights.push_back(0);
        for(int i = 0; i < heights.size(); i++){
            // if heights[i] is smaller than the top of the stack, we need to pop the stack
            // and calculate the area of the rectangle with heights[i] as the height
            // because the stack is in ascending order, so the previous elements are all larger than heights[i]
            // so the width is i - st.top() - 1
            while(!st.empty() && heights[i] < heights[st.top()]){
                int cur = st.top();
                st.pop();
                // if stack is empty, it means that all the previous elements are larger than heights[cur]
                // so the width is i
                res = max(res, heights[cur] * (st.empty() ? i : i - st.top() - 1));
                //the width is i - st.top() - 1, because st.top() is the first element smaller than heights[cur]

            }
            st.push(i);
        }
        return res;
    }
```

## 74 数组中的第k个最大元素

### 题目

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

### 解答

O（n）理论上只能桶排序吧。

但官方给的题解也是nlgn。

想法是可以直接建大根堆，然后删除k次。

或者用priority_queue，保存k个元素，最后输出队列头部。

```CPP
int findKthLargest(vector<int>& nums, int k) {

    priority_queue<int, vector<int>, greater<int>> pq;
    for(int i = 0; i < k; i++){
        pq.push(nums[i]);
    }
    for(int i = k; i < nums.size(); i++){
        if(nums[i] > pq.top()){
            pq.pop();
            pq.push(nums[i]);
        }
    }
    return pq.top();
}
```

但二者时间花费竟然差不多？

还可用基于快排的方法，但不想看了。

## 75 前k个高频元素

### 题目

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

### 解答

先用个map来计数。

然后和上题同样的思路，存下前k大元素，依次存入答案数组即可。

```CPP
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> m;
        for(auto i : nums){
            m[i]++;
        }
        priority_queue<pair<int, int>> pq;
        for(auto i : m){
            pq.push({i.second, i.first});
        }
        vector<int> res;
        for(int i = 0; i < k; i++){
            res.push_back(pq.top().second);
            pq.pop();
        }
        return res;
    }
```

## 76 数据流的中位数

### 题目

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

- `MedianFinder() `初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

### 解答

最经典的方法是用**一个小顶堆加一个大顶堆。**

分别存放大于中位数的，和小于中位数的数据。

每当要新增一个数字时，就进行比较：

1. 如果小顶堆为空，或小顶堆的最大值大于num，就把num加到小顶堆。
2. 否则，插入大顶堆。

此外，为了保持中位数的性质，还需要对两个堆进行调整：

如果任意一边的元素比对面多2个或以上，就要把顶部的挪到对面去。

这是为了保证两边元素数量只相差1个或元素数量相等，才能保证直接通过top得到中位数。

那么在查找中位数的操作时，就可以：

1. 如果两边数量相等，可以直接return两边的top相加再除以二。
2. 如果数量不等，返回数量较多那边的top。

## 77 买卖股票的最佳时机

### 题目

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

### 解答

我们先找到`当前最低价`，作为买入，`第i天出售`，作为售价，然后动态更新最大利润就可以。

因为我们只需要记录最大的利润，所以并不需要一个数组来记录每天所能达到的最大利润，只用一个变量，每次用max更新即可。

```CPP
int maxProfit(vector<int> &prices)
{
    int n = prices.size();
    if (n == 0)
    {
        return 0;
    }
    int dp[n][2];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (int i = 1; i < n; i++)
    {
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = max(dp[i - 1][1], -prices[i]);
    }
    return dp[n - 1][0];
}

//不用dp数组，直接用两个变量
int maxProfit(vector<int> &prices)
{
    int n = prices.size();
    if (n == 0)
    {
        return 0;
    }
    int min_price = prices[0];
    int max_profit = 0;
    for (int i = 1; i < n; i++)
    {
        max_profit = max(max_profit, prices[i] - min_price);
        min_price = min(min_price, prices[i]);
    }
}
```

## 78 跳跃游戏

### 题目

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

### 解答

这个题最开始当成了，在每个位置只能跳指定的格子数。

所以写了这个版本：

```CPP
 bool canJump(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        dp[0] = 1;
        for(int i = 0; i < nums.size(); i++){
            if(dp[i] == 1){
                for(int j = 1; j <= nums[i]; j++){
                    if(i + j < nums.size()){
                        dp[i + j] = 1;
                    }
                }
            }
        }
        return dp[nums.size() - 1];
    }
```

后来又看了遍题目，发现不用这么麻烦，只需要用一个变量维护最大可达到距离就可以了。

```CPP
     bool canJump(vector<int>& nums) {
        int n = nums.size();
        int rightmost = 0;
        for(int i = 0; i < n; i++){
            if(i <= rightmost){
                rightmost = max(rightmost, i + nums[i]);
            }
        }
        return rightmost >= n - 1;
    }
```

就是每次贪心地更新右边界最大值即可。

## 79 跳跃游戏 Ⅱ

### 题目

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

### 解答

我们用一个数字标记目前可以跳到的最远位置，遍历数组更新能到达最远位置。

当遍历的i等于目前的边界时，证明我们需要往前跳了，用可以到达的最远位置更新边界。

然后这样一直更新，就可以。

```CPP
    int jump(vector<int>& nums) {
        int n = nums.size();
        int end = 0;//当前能跳到的最远位置
        int maxPos = 0;
        int steps = 0;
        for(int i = 0; i < n - 1; i++){
            maxPos = max(maxPos, i + nums[i]);
            if(i == end){//到达边界,要往前跳一步了
                end = maxPos;
                steps++;
            }
            if(end >= n - 1){
                break;
            }
        }
        return steps;
    }
```

## 80 划分字母区间

### 题目

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

### 解答

咋办呢？

就先遍历一边数组，更新每个字母出现的最后位置。

然后遍历数组，试图得到一个划分。

每个划分需要有一个边界值，边界值就是在遍历数组时，得到的最大的那个右边界。

如果说我们用于遍历的值到了右边界，那么就证明目前遍历到的字母都包含在此右边界之前，可以更新。

然后我们就可以得到一个分段，分段之后，更新分段开始为右边界位置+1，继续遍历。

```CPP
    vector<int> partitionLabels(string s) {
        vector<int> res;
        int last[26];
        for(int i = 0; i < s.size(); i++){
            last[s[i] - 'a'] = i;
        }
        int start = 0, end = 0;
        for(int i = 0; i < s.size(); i++){
            end = max(end, last[s[i] - 'a']);
            if(i == end){
                res.push_back(end - start + 1);
                start = end + 1;
            }
        }
        return res;
    }
```

由于在过程中我们遇到一个可能的分隔就会划分，所以我们能够贪心地拿到最大值。

## 81 爬楼梯

### 题目

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

### 解答

就利用递推公式，dp[n]=dp[n-2]+dp[n-1]。

dp[1]=1，dp[2]=2。

然后就能往后递推了。

```CPP
    int climbStairs(int n) {
        if(n == 1) return 1;
        int dp[n + 1];
        dp[1] = 1, dp[2] = 2;
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }

```

## 82 杨辉三角

### 题目

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

### 解答

因为官方样例带了图展示了整个过程，这就有点好写了,直接按照规律来写吧。

需要注意的就是，每一行的首尾的1吧。

```CPP
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        for(int i = 0; i < numRows; i++){
            vector<int> row(i + 1, 1);
            for(int j = 1; j < i; j++){
                row[j] = res[i - 1][j - 1] + res[i - 1][j];
            }
            res.push_back(row);
        }
        return res;
    }
```

## 83 打家劫舍

### 题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

### 解答

分析一下就是：

1. 如果只有一天，那么就是第一天的值。

2. 如果是两天，那么就是第一天和第二天的较大值。

3. 以后，任意一天的最大值，要么等于前一天的值，要么等于两天前的值加上今天的，二者取较大的。

4. 最后得到递推式：

   ​	$dp[i]=max(dp[i-2]+nums[i]2,dp[i-1])$

比如：

> nums = {10,2,1,3,1,1,10}
>
>  dp:10 10 11 13 13 14 23

```CPP
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return nums[0];
        int dp[n];
        dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < n; i++){
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[n - 1];
    }
```

## 84 完全平方数

### 题目

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

### 解答

初始化时我们可以当作，任意dp[i]=i，也就是全由1组成。

在更新时，对于每一个dp[i]：

我们用j来遍历平方小于i的所有数。

在更新时，用：

>  dp[i] = min(dp[i], dp[i - j * j] + 1);

这是由于，如果i可以表示为（i-j\*j），那么表示i所需要的数量就是dp[i-j\*j]再加上1（就是加上j*j这个平方数）。

然后我们再更新时一直保留最小值，i也是遍历过程中从小到大，保证了能达到最优解。

```CPP
int numSquares(int n) {
    //复杂度为O(n * sqrt(n))
    int dp[n + 1];
    dp[0] = 0;
    for(int i = 1; i <= n; i++){
        dp[i] = i;//意味着全部由1组成
        for(int j = 1; j * j <= i; j++){
            //更新dp[i]
            dp[i] = min(dp[i], dp[i - j * j] + 1);
        }
    }
    return dp[n];
}
```

## 85 零钱兑换

### 题目

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

### 解答

比较像完全平方数，但这里存在无解的情况，不像上一题因为有`1`，所以肯定有解。

首先对dp数组初始化，初始化为一个比n大的值就可以（保证取不到，能够对最终答案找不到的情况进行判断）。

在我们更新时，使用的判断条件和上一题稍微有一点区别，由于有最优子结构，我们是从小到大求最优解，所以在更新时只需要遍历硬币数组，保证放入当前硬币不会超过面额，更新dp[i]就可以。

```CPP
    int coinChange(vector<int>& coins, int amount) {
        int dp[amount + 1];
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            dp[i] = amount+1;
            for(int j = 0; j < coins.size(); j++){
                if(i - coins[j] >= 0 && dp[i - coins[j]] != amount+1){//这里如果没有第一个条件，判断第二个条件时dp的下标会越界。
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] == (amount+1)? -1 : dp[amount];
    }
```

## 86 单词拆分

### 题目

​	给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

### 解答

最后我们返回的答案是一个`bool`，dp数组就是个`bool`的，初始化为`false`。

然后在遍历更新dp时，每次都遍历字典中的所有串。

取出一个从当前位置往前len（word)长度的一个值，判断这个子串是否在字典中，如果在，就试着更新当前位置，更新为dp[i-len(word)]||dp[i]。

此外，我们可以做一个剪枝操作，我们所需要的只是判断当前`i`位置能否达到，不需要判断能有多少种方法达到，那么我们增加一个判断：如果dp[i]已经true了，那么就不用判断了。

这样能从3ms优化到0ms。

```CPP
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.size();
        bool dp[n + 1];
        memset(dp, false, sizeof(dp));
        dp[0] = true;
        for(int i = 1; i <= n; i++){
            for(int j = 0; j < wordDict.size(); j++){
                int len = wordDict[j].size();
                if(i - len >= 0 && s.substr(i - len, len) == wordDict[j]){
                    if(dp[i])break;
                    dp[i] = dp[i] || dp[i - len];
                }
            }
        }
        return dp[n];
    }
```

## 87 最长递增子序列

### 题目

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

### 解答

o（$n^2$)的比较好想。

就是每次遍历到一个值时，都从头开始遍历，如果num[j]<num[i]，就动态更新dp[i]为max(dp[i],dp[j]+1)。

这样能拿到n方解法。

```CPP
    int lengthOfLIS(vector<int>& nums) {
        //o(n^2) solution
        int n = nums.size();
        if(n == 0) return 0;
        int dp[n];
        dp[0] = 1;
        int res = 1;
        for(int i = 1; i < n; i++){
            dp[i] = 1;
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i]){
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            res = max(res, dp[i]);
        }
        return res;
    }
```

那么nlgn应该咋办呢？

可以用贪心+二分的方法。

我们用一个数组`help`来保存目前的递增序列。

我们想要一个数组尽量长，那么对于一个新扫描到的数字：

如果它比目前的递增序列尾部还大，那么我们直接把它加到递增序列尾部。

否则，我们从头开始，二分遍历数组，找到一个`i`,使得：

`help[i-1]<num[x]<help[i]`

然后把help[i]更新为num[x],这代表着，长度为[i]+1的递增数组，结尾可以取到的最小元素为num[x]。

我们像这样依次更新就可以。

```CPP
  int lengthOfLIS(vector<int>& nums) {
        //o(nlogn) solution
        int n = nums.size();
        if(n == 0) return 0;
        vector<int> dp;
        dp.push_back(nums[0]);
        for(int i = 1; i < n; i++){
            if(nums[i] > dp.back()){
                dp.push_back(nums[i]);
            }else{
                int l = 0, r = dp.size() - 1;
                while(l < r){
                    int mid = l + (r - l) / 2;
                    if(dp[mid] < nums[i]){
                        l = mid + 1;
                    }else{
                        r = mid;
                    }
                }
                dp[l] = nums[i];
            }
        }
        return dp.size();
    }
```

## 88 乘积最大子数组

### 题目

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**子数组** 是数组的连续子序列。

### 解答

一眼动态规划用max更新以i为结尾的数组最大值。

但这样就寄了，为什么呢？因为`负负得正`，如果就这么按照最大值直接更新，会导致漏掉一些情况。

怎么办呢？对于负数，我们可以存以i为结尾，负的最厉害的那个，如果下一个值为负的，那么更新的时候就有可能成为正的最大值。

那么我们可以像这样，用两个dp数组：

一个用于保存以i为结尾的最大值，一个用于保存最小值，分别用max和min来更新。

注意此时求max的时候还要把最小值数组乘积也纳入考虑,同样求最小值也要把最大值纳入考虑。

```CPP
 int maxProduct(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        int dp[n][2];
        dp[0][0] = nums[0], dp[0][1] = nums[0];
        int res = nums[0];
        for(int i = 1; i < n; i++){
            dp[i][0] = max(max(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]), nums[i]);
            dp[i][1] = min(min(dp[i - 1][0] * nums[i], dp[i - 1][1] * nums[i]), nums[i]);
            res = max(res, dp[i][0]);
        }
        return res;
    }
```

## 89 分割等和子集

### 题目

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

### 解答

最开始把题目当成了有序，没注意样例以及`子集`，于是果然寄了：

```CPP
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int i = 0; i < nums.size(); i++) sum += nums[i];
        int sum2 = 0;
        if(sum % 2 != 0) return false;
        for(int i=nums.size()-1;i>=0;i--){
            sum2 += nums[i];
            sum -= nums[i];
            if(sum2 == sum ) 
            return true;
        }
        return false;
    }
```

然后就改：

这类似于一个01背包。

对每个元素，都只有选或不选，然后结束的状态是能够在整个数组中选择部分数，使得背包容量sum/2刚好被用完。

这里可以有一个剪枝：

如果sum为奇数，肯定无法分为两个相等子集，直接false。

然后，怎么写呢？

01背包问题，参考：
[【动态规划/背包问题】那就从 0-1 背包问题开始讲起吧 ... (qq.com)](https://mp.weixin.qq.com/s/xmgK7SrTnFIM3Owpk-emmg)

既然我们去了它的马甲，就按照0-1背包来做：

我们从target开始递减遍历（在更新后面的值时会用到前面的未更新值，我们要递减是由于，如果递增的话，会对前面的值进行更新，从而导致出错）到num[i]，用

> dp[j]=dp[j]||dp[j-num[i]]

来更新状态。

dp[j]代表的是和子集能否取到j：

我们在利用num[i]来更新时：

dp[j]目前的值，等于dp[j]（也就是说，我们的dp中不包括num[i]）

或是等于dp[j-num[i]]（也就是说，如果dp[j-num[i]]能够被取到，那么在dp[j-num[i]]中放入num[i]，dp[j]就能取到了。）

```CPP
    bool canPartition(vector<int>& nums) {
        //o(n^2) time complexity, o(n) space complexity
        int sum = 0;
        for(int i = 0; i < nums.size(); i++) sum += nums[i];
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        bool dp[target + 1];
        memset(dp, false, sizeof(dp));
        dp[0] = true;
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] > target) return false;
            for(int j = target; j >= nums[i]; j--){
                //对每一个nums[i]，都要从target到nums[i]进行遍历。
                //因为如果从nums[i]到target遍历，那么dp[j - nums[i]]可能还没有更新。
                //比如nums = [1, 2, 5], target = 11
                //如果从nums[i]到target遍历，那么dp[11] = dp[10] = dp[9] = dp[8] = dp[7] = dp[6] = dp[5] = dp[4] = dp[3] = dp[2] = dp[1] = dp[0] = true
                //但是dp[5] = dp[5 - 5] = dp[0] = true是不对的，因为dp[0] = false
                //所以要从target到nums[i]遍历，这样dp[5] = dp[5 - 5] = dp[0] = false，dp[6] = dp[6 - 5] = dp[1] = false，dp[7] = dp[7 - 5] = dp[2] = false，dp[8] = dp[8 - 5] = dp[3] = false，dp[9] = dp[9 - 5] = dp[4] = false，dp[10] = dp[10 - 5] = dp[5] = true，dp[11] = dp[11 - 5] = dp[6] = false
                //更新dp[j-nums[i]]是因为如果dp[j-nums[i]]是true，那么dp[j]也是true
                //dp[j-nums[i]]代表的是nums[i]是否可以被加入到dp[j]中
                dp[j] = dp[j] || dp[j - nums[i]];
            }
            if(dp[target]) return true;
        }
        return dp[target];
    }
```

## 90 最长有效括号

### 题目

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

### 解答

1. 用dp。

怎么用呢？

有效的括号匹配肯定是以`)`结尾，所以`(`对应的dp值都为0.

然后当我们扫描的过程中：
如果说对于dp[i]==`)`

那么我们判断：如果`dp[i-1]`==`(`，那么`dp[i]=2+dp[i-2]`，也就是说有效的匹配括号长度增加2。

然后我们再判断，如果dp[i-1]==`)`，那么我们可以看看`dp[i-dp[i-1]-1]`的情况，这个值对应的是以`i-1`结尾的数组的最长字串再向左一个位置。如果能配上，就可以更新为dp[i-dp[i-1]-1]+2.

最后再用一个循环找最大值。

```CPP
 int longestValidParentheses(string s) {
        if(s.size() == 0) return 0;
        int n = s.size();
        int dp[n];
        memset(dp, 0, sizeof(dp));
        int res = 0;
        for(int i = 1; i < n; i++){
            if(s[i] == ')'){
                if(s[i - 1] == '('){
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                }
                else if(i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '('){
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
            }
        }
        for(int i = 0; i < n; i++){
            if(dp[i] > res) res = dp[i];
        }
        return res;
    }
```

2. 可以有不需要额外空间的写法

想想期中考的压轴题：判断是否有效括号的思路。

用一个left和一个right来记录左右括号数。

每当二者相等时，就更新一下当前最大长度。

如果right比left大，就将二者清零，代表重新开始一次括号匹配。

但这会导致对于`(()`的情况无法判断。

解决方法就是，反过来再遍历一次，当left比right大，清零。

```CPP
    int longestValidParentheses(string s) {
        int left=0,right=0;
        int res=0;
        for(int i=0;i<s.size();i++){
            if(s[i]=='(') left++;
            else right++;
            if(left==right) res=max(res,2*right);
            else if(right>left) left=right=0;
        }
        left=right=0;
        for(int i=s.size()-1;i>=0;i--){
            if(s[i]=='(') left++;
            else right++;
            if(left==right) res=max(res,2*left);
            else if(left>right) left=right=0;
        }
        return res;
    }
```

## 91 不同路径

### 题目

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

### 解答

似曾相识：
dp\[i]\[j]=dp\[i-1][j]+dp[i]\[j-1]

初始化第一行和第一列为1。

然后秒了（确信）

哎！竟然会有我都能秒的题！

```CPP
    int uniquePaths(int m, int n) {
        if(m == 1 || n == 1) return 1;
        int dp[m][n];
        for(int i = 0; i < m; i++) dp[i][0] = 1;
        for(int i = 0; i < n; i++) dp[0][i] = 1;
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
            }
        }
        return dp[m - 1][n - 1];
    }
```

## 92 最小路径和

### 题目

给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

### 解答

还是眼熟，就dp嘛，更新的时候用一下min。

```CPP
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.size() == 0) return 0;
        int m = grid.size(), n = grid[0].size();
        int dp[m][n];
        dp[0][0] = grid[0][0];
        for(int i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
        for(int i = 1; i < n; i++) dp[0][i] = dp[0][i - 1] + grid[0][i];
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
    }

```

## 93 最长回文子串

### 题目

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

### 解答

我们可以转化为一个二维的dp。

我们所要求的就是，最长的，满足dp\[i]\[i]到dp\[i][j]的最大的j-i+1。

那么先考虑边界条件：

dp\[i][i]=True。

如果s[i]==s[i+1],那么dp\[i][i+1]=True.

（这里两种初始化是因为，有奇数和偶数的情况）

然后的话，每次对dp的更新都是：

dp\[i][j]=dp\[i+1][j-1]&&s[i]==s[j]。

再用一个start来标记开始位置作为辅助，就可以了。

```CPP
    string longestPalindrome(string s) {
        int n = s.size();
        if(n == 0) return "";
        bool dp[n][n];
        memset(dp, false, sizeof(dp));
        int maxLen = 1, start = 0;
        for(int i = 0; i < n; i++) dp[i][i] = true;
        for(int i = 0; i < n - 1; i++){
            if(s[i] == s[i + 1]){
                dp[i][i + 1] = true;
                maxLen = 2;
                start = i;
            }
        }
        for(int len = 3; len <= n; len++){
            for(int i = 0; i + len - 1 < n; i++){
                int j = i + len - 1;
                if(s[i] == s[j] && dp[i + 1][j - 1]){
                    dp[i][j] = true;
                    maxLen = len;
                    start = i;
                }
            }
        }
        return s.substr(start, maxLen);
    }
```

有个复杂的`Manacher`算法，可以o（n），之后再看吧。

## 94 最长公共子序列

### 题目

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

### 解答

也是一个二维dp。

用dp\[i][j]表示从text1的\[i]到text2的[j]的两个串的最长公共子序列长度。

更新dp时：如果text[i]==text2[j]，就更新dp\[i][j]为dp\[i-1][j-1]+1。

否则更新为dp\[i-1][j]和dp\[i][j-1]中的较大值。

初始化操作会稍微复杂点，具体直接看代码吧。

```CPP
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        if(m == 0 || n == 0) return 0;
        int dp[m][n];
        //dp[i][j]表示text1[0...i]和text2[0...j]的最长公共子序列
        if(text1[0] == text2[0]) dp[0][0] = 1;
        else dp[0][0] = 0;
        for(int i = 1; i < m; i++){
            if(text1[i] == text2[0]) dp[i][0] = 1;
            else dp[i][0] = dp[i - 1][0];
        }
        for(int i = 1; i < n; i++){
            if(text1[0] == text2[i]) dp[0][i] = 1;
            else dp[0][i] = dp[0][i - 1];
        }
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                if(text1[i] == text2[j]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
        return dp[m - 1][n - 1];
    }
```

但如果我们加个边的话，可以简化一下代码：

```CPP
int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        int dp[m + 1][n + 1];
        memset(dp, 0, sizeof(dp));
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                //dp[i][j]表示text1[0...i - 1]和text2[0...j - 1]的最长公共子序列
                if(text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;//最后一个字符相同
                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);//最后一个字符不同
            }
        }
        return dp[m][n];
    }
```

## 95 编辑距离

### 题目

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

### 解答

老熟人了！

当时只知道用，现在总算看的懂了。

首先要发现，对a插入一个字符和对b删除一个字符是等价的。

所以其实只有三个操作：

删除a，删除b，或是替换。

我们用一个二维的dp来写，用dp\[i][j]表示word[i]到word[j]的编辑距离。

先考虑初始化操作：

初始化第一列和第一行：

分别表示a从空串子到b或是b从空串子到a所需要的步骤。

然后用两个for循环来补充中间缺少的部分：

1. 如果二者相等，那么不需要任何额外操作，直接dp\[i][j]=dp\[i-1][j-1]
2. 如果不相等：
   1. 可能进行对其中任意一个删除，取 min(dp\[i - 1][j], dp\[i][j - 1]) + 1。（也就是把word1或者word2的末尾删除一个）
   2. 可能进行对其中任意一个修改，对应dp\[i - 1][j - 1] + 1。(也就是先把二者转为dp\[i-1][j-1]个都相同的，然后再修改其中任意一个的值。)
   3. 在这二者中取较小的值就可。

```CPP
int minDistance(string word1, string word2)
{
    // o(n * m)
    int m = word1.size(), n = word2.size();
    int dp[m + 1][n + 1];
    for (int i = 0; i <= m; i++)
        dp[i][0] = i;
    for (int i = 0; i <= n; i++)
        dp[0][i] = i;
    for (int i = 1; i <= m; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (word1[i - 1] == word2[j - 1]) // 如果相等，不需要替换
                dp[i][j] = dp[i - 1][j - 1];
            // 这里的dp[i - 1][j]和dp[i][j - 1]分别表示删除word1[i - 1]和word2[j - 1]
            // 这里的dp[i - 1][j - 1]表示替换word1[i - 1]和word2[j - 1]
            else
            {
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1;
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1);
            }
        }
    }
    return dp[m][n];
}
```

我操，哥们儿改了之后战胜100%，真牛逼！

但似乎有些别的解法，再看看？

## 96 只出现一次的数字

### 题目

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

### 解答

奇技淫巧！异或！

想想之前的，剑指offer，26个字母，只有一个出现偶数次，用一个int的位来存。

```CPP
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for(int i = 0; i < nums.size(); i++){
            ans ^= nums[i];
        }
        return ans;
    }
```

## 97 多数元素

### 题目

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

### 解答

似曾相识，好像是啊哈算法的最后的那个地方？msra面试题？

这个方法叫**Boyer-Moore 投票算法**，记一记，有空了可以再来看看。

```CPP
    int majorityElement(vector<int>& nums) {
        int ans = 0, cnt = 0;
        for(int i = 0; i < nums.size(); i++){
            if(cnt == 0){
                ans = nums[i];
                cnt++;
            }
            else if(nums[i] == ans){
                cnt++;
            }
            else{
                cnt--;
            }
        }
        return ans;
    }
```

还有一个有趣的方法：

随机选一个初始值，然后验证是不是众数。

理论上有可能永远跑不出来，但我们算期望，可以发现它理论上随机次数的期望为2。

于是还是常数级别：

```CPP
    int majorityElement(vector<int>& nums) {
        //by random
        srand(time(NULL));
        int n = nums.size();
        while(true){
            int idx = rand() % n;
            int cnt = 0;
            for(int i = 0; i < n; i++){
                if(nums[i] == nums[idx]) cnt++;
            }
            if(cnt > n / 2) return nums[idx];
        }
    }
```

## 98 颜色分类

### 题目

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

### 解答

统计0和2，分别放在数组头和尾。

中间的全放1,用两个变量就可以。

当然，虽然跑得快（局部性比较好）这会有个问题就是需要两趟遍历

```CPP
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;
        for(int i=0;i<n;i++){
            if(nums[i] == 0){
                swap(nums[i], nums[left]);
                left++;
            }
            else if(nums[i] == 2){
                swap(nums[i], nums[right]);
                right--;
                i--;
            }
        }
        for(int i=0;i<left;i++){
            nums[i] = 0;
        }
        for(int i=left;i<=right;i++){
            nums[i] = 1;
        }
        for(int i=right+1;i<n;i++){
            nums[i] = 2;
        }
    }
```

如果仅一趟遍历呢？

```CPP
    void sortColors(vector<int>& nums) {
        //一趟遍历的方法
        int n = nums.size();
        int p0 = 0, p2 = n - 1;
        for(int i = 0; i <= p2; i++){
            while(i <= p2 && nums[i] == 2){
                swap(nums[i], nums[p2]);
                p2--;
            }
            if(nums[i] == 0){
                swap(nums[i], nums[p0]);
                p0++;
            }
        }
    }
```

也就是用两个指针标志前面和后面，然后边扫边换。

## 99 下一个排列

### 题目

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

### 解答

除了最后一个外，别的都满足：下一个数比当前大，但大的幅度最小。

也就是说我们要通过交换，找到最小的比当前数字大的值。

我们从后往前，找到第一个非递减的位置i。

然后再从后往前，找到第一个比num[i]大的位置j。

把这两个值交换，此时已经满足了比当前大。

然后再从i+1开始做一个反序。

从后往前看，交换前i+1开始为递增，交换后就会递减了。

就结束了。

```CPP
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        int i = n - 2;
        while(i >= 0 && nums[i] >= nums[i + 1]) i--;
        if(i >= 0){
            int j = n - 1;
            while(j >= 0 && nums[j] <= nums[i]) j--;
            swap(nums[i], nums[j]);
        }
        reverse(nums.begin() + i + 1, nums.end());
    }
```

## 100! 寻找重复数

### 题目

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

### 解答

你能想象吗？

这竟然可以用floyd 转圈圈的方法。

由于范围限制在了1到n上，所以实际上我们可以把每个位置的值都看作指向下一个位置的链表。

由于有值重复出现，那么就相当于存在一对多的关系，有环会指向重复节点。（想象一下，一共有n+1条边，n个结点，这n+1条边肯定能构成环）

（我们在遍历时会有一些节点根本不被访问，但这并不会影响我们寻找答案）

于是用一个快慢指针，找到环之后从头开始再来一次，就能找到入口处。

```CPP
    int findDuplicate(vector<int>& nums) {
        int n = nums.size();
        int slow = 0, fast = 0;
        while(true){
            slow = nums[slow];
            fast = nums[nums[fast]];
            if(slow == fast) break;
        }
        fast = 0;
        while(true){
            slow = nums[slow];
            fast = nums[fast];
            if(slow == fast) break;
        }
        return slow;
    }
```

还有一个方法，果然是位运算，但怎么又没想起来！

肯定是剑指offer/代码随想录啥的里面见过的。

就是说，对于任意一个位，我们统计它出现0和1的次数。

如果数组某一位出现的1的次数多余从1到n这个数组中此位置1出现的次数，那么答案的这个位肯定取1。

**注意这里并不是直接和n/2比较，所以要分开计数。**

```CPP
int findDuplicate(vector<int> &nums)
{
    //位运算
    int n = nums.size();
    int ans = 0;
    for (int i = 0; i < 32; i++)
    {
        int cnt1 = 0, cnt2 = 0;
        for (int j = 0; j < n; j++)
        {
            if (nums[j] & (1 << i))
                cnt1++;
            if (j & (1 << i))
                cnt2++;
        }
        if (cnt1 > cnt2)
            ans += (1 << i);
    }
    return ans;
}
```

