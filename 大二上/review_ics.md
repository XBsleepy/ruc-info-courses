# 复习

## 进制转换

## 知识

$B2U_w：binary\ to\ unsigned$，w是位数，双射函数

$B2T_w(\overrightarrow{x})=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i$

$U2T_w(x)=B2T_w(U2B_w(x))$

$T2U_w=\begin{cases}
x+2^w\ ,x<0\\
x\ ,x\ge0\\
\end{cases}$

截断：

将x补码截断为k位：

$x^`=U2T_k(x\ mod\ 2^k)$

将x无符号截断位k位：
$x^`=x\ mod\ 2^k$

阿姆达尔定律：加速比=$\frac{1}{(1-P)+\frac{P}{S}}$,P为所占时间，S为提高倍数

十进制转二进制：

* 对整数部分除2取余，由低位到高位
* 对小数部分乘2取整，由高位到低位，一直到所需精度或为0





### 考点

* int满足交换律和结合律，但可能会溢出，float的结合律可能不成立
* 8进制，2进制，16进制转换时的补0要注意一下。
* Xor可以用来做加法（另设置了进位逻辑），每个bit都是自己的加法逆元。
* 内存地址是无符号数。
* 强制类型转换结果保持位值不变，只改变解释方式。
* 含有无符号数的式子会隐式全转换为无符号，隐含unsigned导致的问题（负数处理）
* 截断时先按照无符号数截断，然后再转为有符号（如果需要的话）
* short2unsigned：（unsigned）sx=（unsigned）(int)sx，比如short：-12345会变成429454951

## 整数运算

### 知识

无符号加法溢出：

a=x+y;

a>x?0:1;

对于unsigned，无符号数求加法逆元：

x的逆元为$2^w-x$，二者相加和为0  **0的逆元为0而不是$2^w$**。

对补码加法求逆元：

Tmin是自己的加法逆元，别的都是就直接加负号。



### 考点

* 无符号加法溢出判断和处理
* 补码加法正负溢出，注意最大和最小绝对值会相差1
* 整数除2的n次幂，舍入加上一个偏置值以实现负数向0舍入

## 浮点数

### 知识

IEEE浮点表示

* 符号位S
* 尾数M，一个二进制小数，范围$1$~$2-\epsilon$或者0~$1-\epsilon$
* 阶码E，作用是对浮点数加权，权重是2的E次幂（可以负）($2^E$)
* 阶码字段：exp=$e_{k-1}\dots e_1e_0$
* n位小数字段：frac=$f_{n-1}\dots f_1f_0$
* 32位：k=8,n=23;64位:k=11,n=52

1. 规格化值：
   1. exp不全为0也不全为1
   2. 阶码字段被解释为偏置形式
   3. E=e-Bias，e为无符号数$e_{k-1}\dots e_2e_1，Bias=2^{k-1}-1$
   4. exp=E+Bias=E+$2^{k-1}-1$
   5. 指数取值范围：-126,+127;-1022~+1023.
   6. 位数M有个隐式的1
2. 非规格化：
   1. 阶码位表示全为0
   2. 阶码：E=1-Bias=$2-2^{k-1}$，不直接-Bias是为了使值平滑转化（最大非规格和最小规格化）
   3. 位数M=f，不包含1了
   4. 全0或1+全是0，有+0.0和-0.0，一般认为在某些方面不同而别的相同
   5. 阶码全为1，小数全为0，表示无穷，如果小数域非0，则表示NaN
   6. 如果将值的位表示解释为无符号数，那么他们升序排列，就像他们表示浮点数一样，这有助于排序。

一般属性：

* 最小正规格化,$2^{-n-2^{k-1}+2}$
* 最大非规格化,$(1-2^{-n})\times 2^{-2^{k-1}+2}$

浮点数在乘法上不具备分配性

类型转换：

* int2float:不溢出但可能舍入
* int/float2double：精确保留
* double2float：可能溢出也可能舍入
* float/double2int：向0舍入，也有可能溢出，溢出情况未定义。
* rounding可能导致overflow，可能需要右移M，增加E

## 程序机器级表示

### 知识

* 目前的现实中，虚拟地址中高16位必须全置为0，剩下低48位。所以一个地址能指定64TB范围的一个字节。

* 操作数指示符

  * 立即数：$
  * 16个寄存器
  * 内存引用

* 寻址方式:$Imm(r_b,r_i,s)$,s必须是1/2/4/8.有效地址为：$Imm+R[r_b]+R[r_i]\times s$

* mov类指令

  * 源操作数是一个立即数，存在寄存器或者内存中，目的操作数是一个位置，寄存器或者内存地址

    * x86限制两个操作数不能都指向内存位置。
    * 两个操作数要尺寸一致
    * 目的操作数不能是CS，EIP和IP
    * 立即数不能直接传到段寄存器
    * EFlags和IP不能用mov指令设置
    * 

  * mov只会更新目的操作数指定的那些寄存器字节或内存位置，除了movl以寄存器为目的时会将高位4个字节置为0.（任何为寄存器生成32位值的操作都会清楚高位0，是一个惯例）

  * movabsq能以任意64位立即数为源操作数并且只能以寄存器作为目的，而movq只能将32位补码表示的立即数作为源操作数。

    数据移动指令：

    * 0扩展:movz系列，movzbw,movzbl,movzwl,movzbq,movzwq
    * 符号扩展:movs系列，movsbw,movsbl,movswl,movsbq,movswq,movslq,cltq(%eax符号位扩展到%rax)

  * 执行强制类型转换涉及符号和大小时，要先改变大小，再改变符号。

  * 栈顶元素的地址是所有栈内元素中最低的，%rsp保存栈顶元素地址。通常画栈，地址从下往上增大。

  * Pushq =subq+movq

  * lea目的操作数必须是寄存器

  * 位移操作:sal,shl,sar,shr。a为算数,填符号位

  * 位移量如果不是立即数，得存在%cl中，位移多少具体由它的低m位决定，其中,$2^m=w$

  * 条件码：CF,ZF,SF,OF. SF:最近的操作得到的结果为负数，OF：包括正溢出和负溢出。CF：最高位是否进位或借位。比如被减数小于减数，两数和超过当前类型可表达的最大值。ZF：是否得到0

  * 数据移动类（如lea）不改变条件码，逻辑操作会将进位和溢出标志置为0，位移操作，进位标志将设置为最后一个被移出的位，而溢出标志设为0。INC和DEC会将溢出和零标志，但不改变进位标志。

  * cmp操作cmp a，b基于a-b来设置flag；test a，b基于a&b，来设置ZF和SF，SFwhen a&b<0

  * set指令改变一个字节的值。

  * 循环计数器一般用ecx（loop指令for循环）但要做初始变量的检查，是否为负数。

  * 两种循环方式：

    * guarded-do它 执行一个无条 件跳转 跳到循环结尾处 的测试，以 此来执行初始的测试。（有点像do-while但是不do？）
    * jump-to-middle首先用条件分支，如果初始条件不成立就 跳过循环，把代码变换为 do-while 循环。（有点像正常的while？）

  * PC相对寻址是指跳的地址是目标地址和目前地址的相对偏移量。

  * jmp指令执行PC寻址时，程序计数器的值是跳转指令之后那个位置的地址，而不是指令本身所在位置

  * switch语句一般用在开关较多（大于4），值范围跨度较大时使用。

  * jumptable例子：

    * .section .rodata
    * .align 8
    * .L4:
    * .quad .label1
    * .quad .label2

    实现跳转：jmp *.L4(,%rsi,8)

  * call指令跳转到一个函数的起始，而ret条回到调用语句的下一句，继续main函数。

  * leave=mov+pop（mov %ebp,%esp pop %ebp)

  * 传参

    * 寄存器：%rdi,%rsi,%rdx,%rcx,%r8,%r9（从左到右）
    * 多的参数入栈，从右往左依次入栈。

  * callee-save regitster：

    * %rbp，%rbx。%r12~%r14
    * %esp不用存
    * 别的由caller存，callee函数可以随意使用。

  * 栈上局部储存的情况：

    * 寄存器不够用
    * 会用到&操作，取地址，必须有地址可取
    * 数组或结构体变量

![image-20231114195208756](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231114195208756.png)

![image-20231114212502758](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231114212502758.png)

![image-20231115131349222](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231115131349222.png)

### 信手相连

期末考察范围：

* 5、6、7章，汇编：结合体和联合体
* 据说汇编题比较难，有区分度

## 第五章 程序优化

可优化的点：

* 消除低效循环
  * 比如for循环的判断条件处的函数反复调用（**代码移动**）
* 减少过程调用
  * 获取元素时通过直接用下标访问数组会比用函数来调用更快，但这会破坏程序的模块性。
* 消除不必要的内存引用
  * 在循环中存在计算时可以把结果存在临时变量中，结束循环后再赋值给所需要的内存地址，可以减少不必要的访存操作。

### 理解现代处理器

在实际的处理器中，是同时对多条指令求值的，这个现象称为**指令级并行**。

当一系列操作必须按照严格顺序执行时，就会遇到**延迟界限**（latency bound)。 

**吞吐量界限**刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。



**超标量**:每个时钟周期可以进行多个操作，乱序执行，比按序流水线能更好地实现指令级并行。

遇到分支时，会采用**分支预测**和**投机执行**的技术。

其余方法：

* 循环展开
  * 减少迭代次数，减少关键路径的操作数量。
* 提高并行性
  * 多个累计变量，在最后合并来提高性能。（但小心浮点数误差？）
  * 改变结合顺序
* SIMD：向量指令
  * 单指令多数据，高级向量扩展。`AVX`指令集

一些限制因素：

* 寄存器溢出
  * 并行度超过了可用寄存器的数量，导致不得不将临时变量存在内存中。
  * 分支预测和预测错误处罚。
    * 不要过分关心可预测的分支
    * 书写适用于条件传送实现的代码

理解内存性能

* 加载的性能
* 存储的性能

性能提高技术

* 高级设计，选择适当的算法和数据结构

* 基本编码原则：

  * 消除连续的函数调用
  * 消除不必要的内存引用
  * 展开循环
  * 累加
  * 功能性风格重写

  **警惕为了提高效率而导致的错误，比如浮点数溢出，无结合律等问题**

程序剖析



## 第六章 存储器层次结构

### 存储技术

#### 随机访问存储器

分为SRAM和DRAM两类

* SRAM：双稳态，六个晶体管电路实现，双稳态，抗干扰
* DRAM：对电容充电。失去电荷较快，但因为时钟周期小，所以够用。通过周期性读出重写或是纠错码来实现纠错。





##### 传统的DRAM

单元被分为d个超单元，每个都有w个DRAM单元组成，存储d*w位信息。

超单元被组织成r行c列的长方形，rc=d。

内存访问特点：

* 先行后列
* 行先缓存于row buffer
* 从row buffer中访问列

二维阵列组织优缺点：

* 优点：引脚数量少

* 缺点：两步发送地址，增加访问时间

##### 内存模块

DRAM封装在内存模块里

要取出内存地址A处的一个字，内存控制器将A转换成一个超单元地址（i，j），并将它发送到内存模块，然后内存模块再将 i 和j广播到每个DRAM。作为响应，每个 DRAM输出它的（i，j）超单元的8位内容。模块中的电路收集这些输出，并把它们合并成 一个64位字，再返回给内存控制器。

 通过将多个内存模块连接到内存控制器，能够聚合成主存。在这种情况中，当控制器 收到一个地址A时，控制器选择包含A的模块k，将A转换成它的（i,j)的形式，并将. (i，j）发送到模块k。

##### 增强的DRAM

基于传统的DRAM单元，并进行一些优化，提高访问基本 DRAM单元的速度。

* 快页模式
* 扩展数据输出
* 同步DRAM
* 双倍数据速率同步DRAM
* 视频RAM

–快页模式DRAM, FPM DRAM：对同一行连续访问可以直接从行缓冲区得到服务

–扩展数据输出DRAM，EDO DRAM：FPM DRAM的增加形式，允许各CAS信号在时间上靠得更紧密

–同步DRAM，SDRAM：与内存控制器通信采用同步信号

–双倍数据速率同步DRAM，DDR SDRAM：使用两个时钟沿作为控制信号，使DRAM速度翻倍

–视频RAM，VRAM：用于图形系统帧缓冲区，允许并行内存读和写

##### 非易失性存储器

关电后仍能保持信息。

ROM：read-only memory，依据可重编程次数来分类。

* PROM可以被编程一次，原理是存储器单元的熔丝可被高电流熔断一次
* EPROM（可擦可写）擦除重写次数数量级约为1000次
* EEPROM（电子可擦除）1e5的量级
* 闪存 

存储在ROM中的程序被称为固件（firmware），计算机通电后就会运行之（如BIOS）

##### 访问主存

数据流通过总线在处理器和DRAM中来回。

读写都以`movq A，%rax` ` movq %rax，A`为例:

**读**：

–CPU将地址A放到系统总线上

–主存从内存总线读地址，从DRAM取出数据，并写到内存总线

–CPU从系统总线上读数据，并复制到寄存器%rax中

**写**：

–CPU将地址A放到系统总线上

–CPU将%rax中的数据复制到系统总线

–主存从内存总线读出数据，并将这些位存储到DRAM中

**第一步均是读出A地址**

#### 磁盘存储

##### 构造

磁盘由一个或多个盘片组成，每个盘片有两个表面。

通常以每分钟5400~15000速度旋转。

每个表面由一组磁道同心圆构成。

##### 磁盘容量

**容量：**一个磁盘上可以记录的最大位数。

影响因素：

* 记录密度：磁道一英寸段中可以放入的位数
* 磁道密度：从盘片中心发出半径上1英寸段内的磁道数
* 面密度：记录密度*磁道密度

面密度大大提高后，扇区分隔使用的部分损失也增加，为利用这部分空间，现在使用**多区记录**的技术来。

![image-20231209162929538](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231209162929538.png)

注意，制造商按照10进制记录容量。

##### 磁盘操作

磁盘通过读/写头来读写位。

通过沿着半径方向的移动，可以改变读写头所在磁道，称为**寻道**

任何时候所有读/写头都位于同一个柱面上。

对扇区的访问时间主要有三个部分：

* 寻道时间，通常为3~9ms,最大可达20ms

* 旋转时间

  在最坏情况下为：

  $\frac{1}{RPM}\times\frac{60s}{1min}$

  平均时间是这个的一半。

* 传送时间

  依赖于旋转速度和每条磁道下的扇区数目.约为：

  $\frac{1}{RPM}\times\frac{1}{平均扇区数/磁道}\times\frac{60s}{1min}$

总时间是三部分相加。

寻道时间和旋转延迟大致相等，所以将寻道时间乘2是估计磁盘访问时间的简 单而合理的方法。

##### 逻辑磁盘块

磁盘控制器隐藏了复杂的寻找磁盘扇区操作，而是由操作系统发出(盘面，磁道，扇区)的三元组直接访问。

##### 链接I/O设备

##### 访问磁盘

#### 固态硬盘

基于闪存

SSD由一个或多个闪存芯片+闪存翻译层（类似机械驱动器）组成。

读SSD比写要快，这是由闪存基本属性决定的。

一个闪存由B个块的序列组成，每个块由p页组成。

页大小：512KB~4KB, 块: 32~128页

数据以页为单位读写 

页所属的块被整个擦除后才能写该页

块磨损：经过大约100000次重复写后，块磨损坏，不可用。

随机写很慢的原因：

* 擦除块时间较长，1ms级。比访问页搞一个数量级。
* 如果写操作试图修改已有数据的页，就必须将这个块中所有有有用数据的页全部复制到一个已经被擦除过的块里面存起来，才能进行写操作。

#### 技术趋势

增加密度（从而降低成本）比降低访问时间容易得多。

### 局部性

个编写良好的计算机程序常常具有良好的局部性（locality)。也就是，它们倾向于引 用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。

两种形式：

* 时间局部性
* 空间局部性

标量没有空间局部性

每隔k个元素，访问一个向量个元素的函数，具有步长为k的引用模式，一般随着步长增加，空间局部性下降。

#### 取指令的局部性

for循环的时间局部性较好

#### 小结

–重复引用相同变量的程序有良好的时间局部性

>  频繁访问数据集的缓存级别：寄存器>L1 cache>L2 cache-L3 cache>内存

–步长为k的引用模式程序，步长越小，空间局部性越好

>  CPU内存访问单位cache line(64字节)，步长越小，效率越高

–对于取指令而言，循环有好的时间和空间局部性，循环越小，循环迭代次数越多，局部性越好

> 简化循环体内代码结构

### 存储器层次结构

#### 存储器层次结构中的缓存

高速缓存：cache

存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于 A+1层的更大更慢的存储设备的缓存。

数据以块大小为传送单元在k和k+1层之间来回复制。

1. 缓存命中

   当需要第k+1层某数据对象d时，现在当前存储于k层的一个块中查找，如果d刚好在k中出现，就是命中了，直接从第k层读取d比从d+1层读取更快。

2. 缓存不命中

   缓存不命中时，第k层会从k+1层中取出包含d的那个块。如果已经满了，就可能会覆盖已有的。

   这个过程称为替换或者驱逐。决定替换哪一个由替换策略控制。

3. 不命中的种类

   * 冷缓存：k层是空的。此类情况被称为强制性不命中或冷不命中

     一般不会在反复访问存储器使得热身之后的稳定状态中出现

只要发生了不命中，就会执行放置策略。如果随机放置，代价会很高。

通常会将k+1层的某个块限制放在k层的一个小子集中。

由此引起：冲突不命中

在这种情况中，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。

当工作集大小超过缓存时，会经历容量不命中，也即是缓存太小无法处理此工作集。

4. 缓存管理

   存储器层次结构的本质是，每一层存储设备都是较低一层的缓存。

#### 概念小结

![image-20231209182907385](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231209182907385.png)

### 高速缓存存储器

#### 通用组织结构

考虑一个计算机系统，其中每个存储器地址有 饥 位，形成 $M=2^m$个不同的地址。

样一个机器的高速缓存被组织成一个有 $S=2^s$个高速缓存组（cache set)的数组，每个数组有E个高速缓存行。

每行有$B=2^b$个字节的数据块。

有一个有效位用于标识是否含有有效信息，还有t=m-（b+s)个标记位，用于唯一标识行块。

![image-20231221145448150](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231221145448150.png)

一般可用元组(S,E,B,m)来描述高速缓存的结构。

高速缓存大小值所有块的和，不包括标识，故$C=S\times E\times B$

加载指令指示读取一个字时，将地址A发送到高速缓存，如果其中有这个字的副本，就直接返回给CPU，如果不包含 ，可通过类似于简单的哈希函数的哈希表来找。

具体过程：

![image-20231221150038562](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231221150038562.png)

数据符号定义小结：![image-20231221150046054](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231221150046054.png)

#### 直接映射高速缓存

据每个组的高速缓存行数 E， 高速缓存被分为不同的类。每个组只有一行(E=1)的 高速缓存称为直接映射高速缓存。

执行过程：
CPU读字w->向L1请求->L1中有（缓存命中）

不命中，则会向主存进行请求，拿到副本。（此时cpu等待）

判断是否命中并抽取出字的过程：

1. 组选择

   从w地址中抽取出s个索引位，解释为对应于组号的无符号整数。用作索引

2. 行匹配

   此时已经选定组i，接下来要判组中断是否有行w。由于此处认为组中只有一行，所以当且仅当设置了有效位且标记与w的标记匹配时，包含。

3. 字抽取

   命中后的最后一步，确定字w开始位置。块偏移位决定了第一个字的偏移。字节偏移是这个数组的一个索引。注意是二进制，100代表从块的第四个字节开始。

如果不命中，它会从下层取出需要的块，然后将新块放到索引指示的组的高速缓存行中。一般情况下需要去除一个已有的行来进行替换。

![image-20231221153046981](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231221153046981.png)

![image-20231221161348608](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231221161348608.png)

冲突不命中很常见，党访问大小为2的幂的数组是，直接映射高速缓存通常会发生冲突不命中。

`抖动`，即使程序有良好的空间局部性，而且我们的高速缓存中也有足够的空间 来存放 x[i]和 y[i]的块，每次引用还是会导致冲突不命中，这是因为这些块被映射到了同一个高速缓存组。

可以通过增加填充来消除抖动冲突不命中。

![image-20231221162459631](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231221162459631.png)

#### 组相联高速缓存

冲突不命中源于每个组只有一行。

现在讨论1<E<C/B的情况，被称作E路组相联高速缓存。

组选择和直接映射高速缓存的组选择一样，组索引位标识组。

行匹配得检查多个行标记位和有效位，来确定请求字。

相联存储器是一个键值对数组。

组相联高速缓存的每个组都可以看做一个小的相联存储器。

key是标记和有效位，value是块内容。

行匹配的重要思想是，组中任何一行都可以包含仍和映射到这个组的内存块。所以高速缓存必须搜索组中的每一行， 寻找一个有效的行，其标记与地址中的标记相匹配。如果高速缓存找到了这样一行，那么 我们就命中，块偏移从这个块中选择一个字，和前面一样。

不命中时的行替换：

如果有空行，优先放到空行黎。

可以使用最不常使用策略或者最近最少使用策略。

#### 全相联高速缓存

E=C/B

只有一个组。

行匹配和字选择和组相联一样。

![image-20231222134538892](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222134538892.png)

#### 写

假设要写一个已缓存的字（写命中）

![image-20231222134822202](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222134822202.png)

#### 例子

高速缓保存数据也保存指令（i-cache)。

不想看了

#### 性能影响

![image-20231222135901156](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222135901156.png)

![image-20231222135916546](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222135916546.png)

![image-20231222140327461](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222140327461.png)



#### 写高速缓存友好代码

1. 让最常见的情况运行的快。
2. 减少循环内缓存不命中数量。
3. 相关的重要问题：
   * 对局部变量反复引用很好。
   * 步长为1的引用模式很好

### 高速缓存对程序性能的影响

#### 存储器山

一个程序从存储系统中读数据的速率称为读呑吐量（read throughput)，或者有时称为 读带宽（read bandwidth)，如果一个程序在 s 秒的时间段内读 n 个字节，那么这段时间内 的读吞吐量就等于 ，通常以兆字节每秒（MB/s)为单位。

如果我们反复以不同的 size 和 stride 值调用 们就能得到一个读带宽的时间和空间局部性的二维函数，称为存储器山。

即使是当程序的时间局部性很差时，空间局部性仍然能补救，并且是非常重要的。

#### 重排提高空间局部性

![image-20231222142559514](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222142559514.png)

在程序中利用局部性

![image-20231222142633133](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222142633133.png)

![image-20231222142734223](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222142734223.png)

## 第七章 链接

==习题7.1要掌握==

链接可以在编译时执行，也可以在加载时执行，甚至是运行时执行。现代体系中，由链接器来实现。

连接器使得分离编译成为可能。

### 编译器驱动程序

![image-20231222143041804](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222143041804.png)

#### 静态链接

静态链接器（static linker)以一组可重定位目标文件和命令行 参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

连接器的任务：

* 符号解析。将每个符号引用与对应的符号定义关联起来。
* 重定位。生成从地址0开始的代码数据节，连接器把符号定义与内存关联。

### 目标文件

![image-20231222150456053](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222150456053.png)

### 可重定位目标文件

![image-20231222184332809](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222184332809.png)

![image-20231222184654041](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222184654041.png)

![image-20231222184704827](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231222184704827.png)

### 符号和符号表

每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。在 链接器的上下文中，有三种不同的符号。

* 由m定义且能被其他模块引用的全局符号。

* 由其他模块定义并被m引用的全局符号，这些都被称为外部符号。

* 只被m定义和引用的局部符号。（static的c函数和全局变量）在m中任何位置均可见，但是不能被其他模块引用。

  

### 符号解析

链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的 一个确定的符号定义关联起来。

#### 解析多重定义的全局符号

对多个模块定义的同名全局符号，linux处理办法：

判断每个全局符号是强或者是弱，编码在可重定位目标文件的符号表里。

函数和已经初始化的变量强符号，为初始化的为弱符号。


* 规则 1: 不允许有多个同名的强符号。

* 规则 2: 如果有一个强符号和多个弱符号同名，那么选择强符号。 
* 规则 3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。

通常连接器不会表明它检测到了多个x的定义。可能导致一些不易察觉的错误。

比如：x的定义其中一个为double，另一个为int。

#### 与静态库链接

所有的编译系统都提供一种机制，将所有相关的目标 模块打包成为一个单独的文件，称为静态库（static library)。

种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码。这种方法对 C 而言是不合适的，因 ! 为 C 标准定义了大量的标准函数。这种方法将给编译器增加显著的复杂性。

另一种方法是将所有的标准 C 函数都放在一个单独的可重定位目标模块中（比如说 中)应用程序员可以把这个模块链接到他们的可执行文件中。这种方法的优点是它将编译器的实现与标准函数的实现分离开来，

一个很大的缺点是系统中每个可执行文件现在都包含着一份标准 函数.集合的完全副本，这对磁盘空间是很大的浪费。

另一个大的缺点是，对任何标准函数的任何 改变，无论多么小的改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时的操作，使得标准函数的开发和维护变得很复杂。

**静态库**概念被提出来，以解决这些不同方法的缺点。相关的函数可以被编译为独立的 目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定 单独的文件名字来使用这些在库中定义的函数。

在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内 存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字。

在 Linux 系统中，静态库以一种称为存档（archive)的特殊文件格式存放在磁盘中。存 档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文 件的大小和位置。存档文件名由后缀.a 标识。

#### 连接器如何使用静态库来解析引用

` Linux` 链接器使用它们解析外部引用的算法

![image-20231225132155910](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231225132155910.png)

这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文 件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件 之前，那么引用就不能被解析，链接会失败。

### 重定位

完成符号解析之后，要把每个符号引用和符号定义关联起来。

## final

* PC： %rip，给出将要执行的下一条指令地址。
* 生成1、2字节的数字会保持剩下字节不变，但四字节指令会把高位置0
* Imm指令的比例因子只能是1、2、4、8,基址寄存器和变址寄存器都是64位
* X86-64 中的内存引用总是用 四字长寄存器给出，例如％rax，哪怕操作数只是一个字节、一个字或是一个双字。
* 强制类型转换涉及大小+符号时，先改变大小再改变符号。
* pop是将弹出值给rax
* lea目的操作数必须是寄存器
* 一般逻辑位移的位移大小用%cl
* XOR会置零CF和OF
* 跳转指令：PC相对偏移量。值是相对于跳转指令后的那个地址位置。
* 分支预测错误处罚：$T_{(avg)}(p)=(1-p)T_{OK}+p(T_{OK}+T_{MP})$,MP是预测错误处罚，Ok是执行代码时间。
* switch与jumptable，当开关情况较多且值跨度较小时使用。
* 通过栈传递参数时，数据都向8位对齐，第七个参数放在栈顶。
* 过程通过减小栈指针分配空间
* rbx，rbp，r12到15是被调用者保存。
* 任何类型的指针都是 8 个字节长。
* 指针 s+立即数，得到的地址是s+立即数*元素大小
*  $\&D[i][j]=x_D+L(C \cdot i+j)$
* union:用多种类型来引用同一个对象，用不同字段引用相同代码块。
* 对齐的原则是任何k字节的基本对象地址都必须是k的整数倍。
* SSE必须16字节对齐。
* 强制转换指针类型只改变类型不改变具体值。
* 申请数组长度用malloc时要加1，存放结尾的null
* 金丝雀，栈随机化与nop，限制可执行区域。
* 内存别名使用时要考虑相同引用的情况
* 程序优化
  * 消除低效循环
    * 比如for循环的判断条件处的函数反复调用（**代码移动**）
  * 减少过程调用
    * 获取元素时通过直接用下标访问数组会比用函数来调用更快，但这会破坏程序的模块性。
  * 消除不必要的内存引用
    * 在循环中存在计算时可以把结果存在临时变量中，结束循环后再赋值给所需要的内存地址，可以减少不必要的访存操作。
  * 循环展开，作用是减少迭代次数，注意边界元素处理。但单纯增加k并不能达到吞吐量界限，依然无法低于延迟界限。
  * 多变量累积
    * 理论上，对于延迟为L，容量为C的操作，k≥CL时达到吞吐量界限。
    * 但必须考虑结果正确性，整数可结合不影响，但是浮点数不可结合有影响。
  * 重新结合变换
    * 2*1a展开，改变括号位置改变运算顺序。（？）
* 指令级并行
* 延迟界限是必须顺序执行，吞吐量界限是原始性能，终极限制。
* 超标量：乱序处理器。有更好地指令级并行度
* 每 个运算都是由以下这些数值来刻画的.•一个是延迟（latency), 它表示完成运算所需要的总 时间；另一个是发射时间（issue time), 它表示两个连续的同类型的运算之间需要的最小 时钟周期数；还有一个是容量（capacity)，它表示能够执行该运算的功能单元的数量。
* 加法和乘法运算的发 射时间都为 1，意思是说在每个时钟周期，处理器都可以开始一条新的这样的运算。这种 很短的发射时间是通 过使用流水线实现的。
* 发射时间为 1 的功能单元被称为完全流水线化的（fully pipelined): 每个时钟周期可以开始一个新的运 算。
* 除法器(用于整数和浮点除法，还用来计算浮点平方根）不是完全流水线 化的.
* 的最大呑吐量，定义为发射时 间的倒数。一个完全流水线化的功能单元有最大的吞吐量
* 数据流图，只写只读局部循环。循环寄存器之间的操作链限制了性能。
* 制约因素
  * 寄存器溢出，超过数量。
  * 分支预测错误
* ![image-20240104180122522](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20240104180122522.png)

* 具有相同编号的磁道形成一个圆柱,称之为磁盘的柱面。一个面的柱面数等于磁道数。
* 磁盘以扇区大小的块来读写数据。访问时间=旋转+传送+寻道。可以用2倍寻道时间来大致估计。计算时注意单位换算。
* max旋转=1/RPM*60s/1min，就是转一圈需要多少秒，平均为其一半
* seek题目给
* 平均传送=1/RPM*1/（平均扇区数/磁道）*60s/min  （读取一个扇区的时间）
* 局部性：
  * 重复引用相同变量的程序有良好的时间局部性。 
  * 对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为 1的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局 部性会很差。 
  * 对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越 多，局部性越好。 
* 冷不命中冲突不命中容量不命中

![image-20240104222822676](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20240104222822676.png)

* 如果高位用做索引，那么 ： 一些连续的内存块就会映射到相同的高速缓存块。相比较而言，以中间位作为索引，相邻 的块总是映射到不同的高速缓存行。
* 地址顺序是标记+索引+偏移，所以说索引是中间。
* 直写高速缓存通常非写分配，协会高速缓存通常写分配。
* 缓存成本与性能
  * 高速缓存大小
  * 块大小
  * 相联度
  * 写策略
* 高速缓存友好代码：
  * 步长为1引用模式
  * 局部变量反复引用
* 静态链接链接器构造可执行文件，完成符号解析和重定位。
* 目标文件有三种，可重定位，可执行，共享目标文件。
* bss：未初始化全局和静态c变量。data：已初始化。
* 三种符号：模块定义并被其他地方引用的全局符号，非静态C函数和全局变量。其他模块定义被本模块引用的全局变量。被m定义+引用的，static全局变量。
* c static不是在栈中管理的，会在data或bss中分配空间。
* 静态函数 static function，只能在本文件被调用。
* 静态库：将所有相关的目标模块打包为一个单独文件。
* 存档文件是一组连接起来的可重定向目标文件集合。、
* 连接器使用静态库解析引用时，如果定义一个符号的库出现在引用这个符号的目标文件之前，引用就无法被解析。
* 重定位包括重定位节和符号定义，重定位节中符号引用。
* ![image-20240105012636952](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20240105012636952.png)

* 静态库缺陷：定期维护和更新，标准I/O函数代码复制到进程文本段，对运行上百个进程的系统来说会造成内存浪费。
* 共享库用于解决这一问题。是一个目标模块，可以在运行时加载到任意内存地址并和那个位置程序链接。有动态连接器完成。（dll）
* 在内存中，一个共享库.text节的副本可以被多个内存中程序共享。
* 动态链接用于分发软件，构建高性能web服务器等。
* 可以加载而无需重定位的代码称为位置无关代码。
* 
  * COMMON： 未初始化的全局变量
  * .bss： 未初始化的静 态变量 ，以 及初始化为 0的全局或静态变量
  * todat_a: 只读数据 如printf式串和开关语句的跳转表。
  * symtab: —个符号表，它存放在程序中定义和引用的函数和全局变量的信息。
  * data: 已初始化的全局和静态 C 变量。
