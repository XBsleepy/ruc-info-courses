## 基本概念

数据

数据元素：数据基本单位，可由若干数据项构成。

数据对象：具有相同性质的数据元素集合。

数据类型：

* 原子类型，值不可再分
* 结构类型，可分解为若干成分
* 抽象数据类型，抽象数据组织及其相关操作

数据结构：相互存在一种或多种特定关系的数据元素的集合。包括：逻辑结构，存储结构，数据运算。

逻辑结构：与存储无关，描述逻辑关系，包括线性和非线性。

存储结构：又叫物理结构，指主数据在计算机中的表示。包括元素的表示和关系的表示。如顺序、链式、索引、散列。

算法五个特性：有穷性、可行性、确定性、输入、输出。

目标：正确性、可读性、健壮性、高效与低存储量需求。

题型：
复杂度分析、基础概念辨析。

## 线性表

定义：n个相同数据类型的数据元素的有限序列。n为表长。a1是表头元素，an是表尾元素。注意前驱与后继关系。

**线性表是逻辑结构，表示一对一相邻关系。顺序表和链表是存储结构，注意辨析。**

### 顺序表

地址连续，逻辑顺序与物理顺序相同。支持随机存取。通常用数组来描述。

可以是静态分配和动态分配。

动态分配是指占满空间时就新开辟一个大空间，把元素复制过去，而不是一次性开辟一个大的。

**动态分配不是链式存储**

顺序查找、插入和删除操作平均时间复杂度都是O（n）

### 链式表示

单链表：data|next。每个结点有数据域+指针域。

非随机存储。

头结点：带头结点链表的第一个结点，通常内部无信息。

头指针：无论有无头结点，头指针都指向链表第一个结点。（有头结点时指向头结点）

头节点优点：

* 无需对第一个元素进行特殊处理
* 无论链表是否为空，头指针都是指向头结点的非空指针，统一了空表和非空表的处理。

头插法：

将节点插入表头，读入顺序与链表元素顺序相反。注意观察下有没有头结点。若单链表表长为n，时间复杂度O（n）

尾插法：

从尾部插入，需要增加一个指向末尾的尾指针辅助操作。

按序号、按值查找复杂度都是O（n）

插入结点复杂度O（n），时间花在查找上，如果给定结点，复杂度O（1）。

注意：前插操作，理论上要再遍历一次找到前一个结点，但可以借助一个辅助空间：

pre->now,temp=now,pre->insert,pre->insert->temp。

就是把目前位置变为插入元素，把目前元素的值后插。能够O（1）。

删除\*p：

可以用删除\*p后继的操作实现，就是把后继结点的值赋予自身，删除后继，就不用找之前的结点了，能够O（1）。



双链表：设立两个指针，一个指向前驱，一个指向后继。

循环单链表：尾结点的next指向头结点，形成一个环。注意考虑插入和删除操作会不会改变尾指针。判空条件变为判断头结点的指针是否等于头指针。

循环双链表：就是有前驱有后继。

静态链表：借助数组来描述链式存储，也有data|next。指针是结点的相对地址（数组下标）又称游标。

## 栈和队列

### 栈

栈：只允许在一端插入或删除的线性表，首先，是一个线性表。

LIFO

n个不同的元素进栈，出栈元素的不同排列个数：$\frac{1}{n+1}C^n_{2n}$（卡特兰数）。这个玩意儿甚至会出现在之后树/图的部分，与遍历顺序啥的联系起来。

栈可以用顺序表实现，怎加一个int类型的top来表示栈顶就可以。

栈判空和判满注意下具体条件。

共享栈：两个顺序栈共享一个一维数组空间，向中间增长。栈满时两个栈顶指针相邻（top1-top0=1）。只有在空间塞满时才会上溢。

链式存储，就那样吧，指针指向表头，不设置头结点.

**栈和队列有相同的逻辑结构**

采用非递归方式重写递归程序不一定用栈:斐波那契迭代实现.

### 队列

操作受限线性表,一端插,另一端删.FIFO.

队头:删除端;队尾:插入端.

如果直接采用顺序存储,存在"假溢出",front指向队头元素,rear指向队尾元素的下一个位置.(不一定,也有可能指向队尾元素)

所以使用循环队列:

利用取余方式实现.

队空的判断: front=rear.

有三种区分队满和空的方式:

1. 牺牲一个存储单元来区分,入队时少用一个队列单元,当队头指针再尾指针下一个位置时作为队满的标志.

2. 增加一个用来表示元素个数的数据成员Q.size
3. 增加一个tag数据成员,用来区分空还是满.1为满.

链式存储.

有一个头指针和一个尾指针.分别指向头结点和尾节点(注意,顺序存储时可能是指向队尾元素下一个位置)

#### 双端队列

两端都可以入队和出队.

输出受限:一端出两端入;

输入受限:一端入两端出,蜕变为两个栈底相邻接的栈.

### 栈和队列的应用

#### 栈与括号匹配



![image-20231228112231812](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228112231812.png)

#### 栈与表达式求值

中缀转后缀,后缀转中缀.

![image-20231228112353587](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228112353587.png)

#### 栈与递归

可以借助栈将递归转为非递归.

#### 队列与树的层次遍历

![image-20231228112558831](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228112558831.png)

### 矩阵和数组

存储:行有限和列有限存储.

特殊矩阵:
压缩存储:多个相同的值只分配一个空间,0元素不分配,以达到节省存储空间的目的.

特殊矩阵:对称,上下三角,对角阵等.

1. 对称阵

   分为上三角区,主对角区和下三角区。节省空间可以只存上三角+主对角线。

2. 三角阵

   有一个半区的元素全是`常量`，故相比于对称阵，需要在最后增加一个存储常数项的位置。

3. 三对角

   元素集中在主对角线附近。

4. 稀疏矩阵

   非零元素很少的矩阵。

   可以用三元组来存（行标，列表，值），这会失去随机存储的特性。

   同时注意对它进行转置时的问题：

   遍历col，找到每列有几个，记录下位置，依次存，再转置。这是为了保证转置后仍然有序。

   可以用**十字链表**来存。

广义表：

数据元素有相对次序。

长度是最外层包含元素个数

深度是括弧重数

”原子“深度是0，”空表“深度1长度0.

可以是递归的表，深度无穷，长度有限。

表的分解：

head（ls）=a1

tail（ls）=（a2，。。。，an）.

使用tail时候要注意在外面套括号。

## 串子

不会真考吧？？？

KMP不会真考吧？

next[j]的含义是在字串的第j个字符与主串失配时跳转到字串的j重新与当前位置进行比较。

匹配时，如果失配，i指针不变，j退回到next[j]的位置，若j为0，则i和j都＋1. 

nextval：递归将next[j]修正为next[next[j]]直到$p_j!=p_{next[j]}$

## 树和二叉树

### 树的定义和基本概念

有n个结点，n=0时是空树，任意非空树满足：
1个根节点

n>1时可以分为m个互不相交有限集，其中每一个集合本身又是一棵树，并且称为根的子树，递归定义。

树是逻辑结构、分层结构。

n个结点的树有n-1条边。

基本术语：

祖先与兄弟与子孙

度、深度、高度、层次

有序树和无序树

路径和路径长度：

​	路径长度是路径上所经过的边的个数。

森林

![image-20231228122957799](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228122957799.png)

* 总节点数=$\sum_0^m n_i$
* 总分支数=$\sum_1^m in_i$
* 总节点数=分支+1

### 二叉树

定义：每个结点之多两个子树（度<=2),有序，左右支不能颠倒。

共五种形式。

二叉树不等于度为二的有序树：

​	二叉树可以空，后者至少3个结点。

​	度为2的有序树的左右次序是兄弟节点之间，也就是说如果某个结点只有1个孩子，那么就没有左右之分。

特殊二叉树：

1. 满二叉树

   $2^h-1$个结点

2. 完全二叉树

   i<=n/2向下取整则为分支结点，否则叶结点。

   叶结点只会出现在最后两层

   度为1的结点最多1个且只有左孩子没有右孩子

   层序编号后如果某结点为叶结点或度为1，则此后所有结点都是叶结点

   若n为奇数，每一分支都有左右孩子，若n为偶数，n/2只有左没有右。

3. 二叉排序树

4. 平衡二叉树

5. 二叉堆

二叉树性质：

1. $n_0=n_2+1$
2. 第k层最多$2^{k-1}$个结点
3. 至多有$2^{h}-1$个结点（满二叉树）
4. ![image-20231228124225042](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228124225042.png)

#### 存储二叉树

1. 顺序存：

   适合完全二叉树和满二叉树，因为由上面的那些性质。

   注意得从下标1开始存

2. 链式存储：

   left|data|right，也可增加指向父结点的。

### 二叉树遍历

先序：NLR，中序：LNR，后序：LRN

中序非递归：

![image-20231228131002159](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228131002159.png)

层次遍历：从左向右依次就行。借助队列实现。

确定二叉树：

先序+中序

后序+中序

层序+任意



#### 树和森林

树的存储：

1. 双亲表示法，用连续空间来存储，增设伪指针，指示其双亲下标。

   可以很快得到双亲，但是求孩子结点时需要遍历。

2. 孩子表示法，每个结点的孩子都用单链表串起来。

3. 孩子兄弟表示法，左手拉孩子，右手拉兄弟。优点是方便转为二叉树，缺点是找不到爹妈，可以增加一个指向父母的。

树、森林与二叉树转换：

二叉链表可以作为媒介导出树和二叉树的对应关系。

树转二叉树：孩子兄弟表示法。

森林转换为二叉树也类似，根节点的右孩子拉别的根节点就可以。

二叉树转为树或森林是唯一的。

#### 遍历

树：

1. 先根遍历，非空树先访问根节点在访问别的。与二叉树先序相同。
2. 后跟遍历，下访问根节点的每颗子树在访问根节点。与二叉树中序相同。

森林：

1. 先序遍历森林。第一棵树的根，先序遍历第一棵树根节点的子树森林，先序遍历去除第一棵子树后的森林。与二叉树先序相同。
2. 中序遍历森林。与二叉树中序相同。

如果一个森林有n个非终端结点，那么转为二叉树后会有n+1个右空指针。

### 应用！

### 哈夫曼树与编码

定义：使得带权路径长度和最短的二叉树叫哈夫曼树，也叫最优二叉树。（不一定是满二叉树）
$$
WPL=\sum^n_{i=1} w_il_i
$$
w为叶子结点的权，l为路径长度。

构造：

每次把权最低的两个点并在一起，他们的双亲结点是二者权值的和。

直到最后只剩一棵树。

此过程共新建n-1个结点，故总节点数为2n-1/

哈夫曼树没有度为1的结点。

#### 编码

可变长度编码

频率越高（权值越大），应该越短。

哈夫曼树不唯一，因为左右结点顺序任意。但WPL一定相同。

## 我的图图呢？

### 基本概念

图：边集+点集。

图不能是空图，是说点集不能为空，但边集可以。

1. 有向图

   边：<a,b>a指向b，a是弧尾，b是弧头。（想想箭头的样子）

   是有序的。

2. 无向图

   （a，b）ab位置可以换，无序的。

3. 简单图和多重图

   简单图：

   1. 没有重复的边
   2. 没有自身到自身的边

   多重图：

   与简单图相对。

4. （简单）完全图

   n个顶点简单无向图的边数取值为0到n(n-1)/2，如果取最大值就是完全图。而有向图取值是这个的二倍，被称为有向完全图。

5. 子图

   注意不是任意的边点子集都能构成子图，边集中的点必须在点集里才行。

   如果子图和图的点集相同，则称为生成图。

6. 连通

   无向图：

   如果v到w有路径，则称两点为连通的。如果任意两点都连通，就是连通图。其中，极大连通子图称为连通分量。**单个的点也是连通分量**。

   如果边数少于n-1，那么必非连通图。非连通图最多有(n-1)(n-2)/2条边。

   有向图：

   如果任意两点互相有路径，称为强连通。

   有向图的极大强连通子图称为强连通分量。

   **单个的点也是强连通分量**

   n个顶点有向图至少要n条边才能强连通。（环）

   ==无向图讨论连通性，有向图讨论强连通性==

7. 生成树和森林

   生成树：包含所有顶点的极小连通子图。

   如果是非连通图，它的连通分量的生成树构成了它的生成森林。

8. 度

   依附于顶点的边数。

   无向图的度的和是边的二倍

   无向图的入读+出度的和是边的二倍

9. 路径和回路

   从a到b的路径就是一次经过的点，注意包括a和b。

   如果出发和结束的节点相同，则称为环或贿赂。

   n个顶点有大于n-1条边，就肯定有环。

10. 距离

    a到b的最短路径长度（存在时）。

11. 简单路径和简单回路

    不出现重复节点是简单路径。

    最短路径一定是简单路径。

    简单回路是只有首末结点相同的环。

### 图存储和操作

1. 邻接矩阵

   一个n*n的矩阵。如果无权图，则用1和0来区分有无边。

   如果有权图，对应为权值，没边的地方可以是0或无穷。

   空间复杂度为O（n^2)，n为顶点数。

   无向图必为对称阵。第i行/i列非0个数为度。

   有向图第i行为出度，第i列为入度。

   确定有多少条边必须按行按列过一遍，O（n^2)

   A^n的元素ij代表从i到j的长度为n的路径有几条。

   邻接矩阵表示唯一。

2. 邻接表

   每个结点连着自己的相邻节点们。

   边表头指针和顶点的数据用顺序表存，称为顶点表。

   无向图中每条边会被存两遍。

   空间花费：

   无向图O(V+2E)有向图O(V+E)

   给一定点找邻边只需要直接读邻接表。而邻接矩阵需要扫描一行，花费O（n），但可以直接确定a，b之间是否有边，而邻接表需要遍历。

   邻接表表示不唯一，因为结点连接顺序任意。

3. 十字链表

   用于有向图。

   弧对应弧结点，顶点对应顶点结点。

   顶点结点

   | data | firstin                | firstou                |
   | ---- | ---------------------- | ---------------------- |
   |      | 以此为头的第一个弧结点 | 以此为尾的第一个弧结点 |

   弧结点：

   | tail_vex | head_vex | hlink              | tlink              | (info) |
   | -------- | -------- | ------------------ | ------------------ | ------ |
   | 弧尾编号 | 弧头编号 | 弧头相同的下一节点 | 弧尾相同的下一节点 |        |

   

注意定点节点之间是顺序存储的，十字链表不唯一。



4. 邻接多重表

   无向图的链式存储

   | ivex     | ilink         | jvex     | jlink           | info |
   | -------- | ------------- | -------- | --------------- | ---- |
   | 顶点编号 | 下一条有i的边 | 顶点编号 | 下一条依附j的边 |      |

   

### 图遍历

广度优先搜索

从i开始以次访问和它相邻的结点。不是递归，可用辅助队列。

与二叉树的层序遍历结果一致，可以看作它的拓展。

性能：

空间复杂度O(V),搜顶点O（V），查找邻接点O(E)总复杂度O（V+E）

如果用邻接矩阵，查顶点邻接点要O（n),故为n方复杂度。

用bfs可以解决无权图单源最短路径（想想魔方）

通过广度优先遍历可以得到一颗遍历树，叫做广度优先生成树，如果用邻接矩阵，则树唯一，邻接表，树不唯一。

深度优先搜索

类似于先序遍历。

遍历序列唯一性同bfs

性能：

递归的，空间O（V），时间：邻接矩阵，O（V^2),邻接表，查找所有顶点邻接点的时间O（E），访问顶点O（V）总O（V+E）

生成树也和bfs类似。

#### 判断连通性

遍历算法能够判断是否连通，如果连通，遍历一次就能访问所有顶点。非连通只能访问到对应的连通分量。

### 图应用

#### 最小生成树

性质：

1. 不唯一，除非各边权值各不相等。
2. 权值之和唯一且最小。
3. 边数=n-1

Prim：

贪心找目前未连接的点中权值最小的连入。

Kruskal：

贪心找权值最小的结点连起来。（需要边的两个结点在不同连通分量中）

最短路径：
Dijkstra算法：

1. 从选中节点开始，访问可以达到的节点。
2. 从已经能达到的节点中，访问未访问过，路径最短的那个，并加入集合中然后访问它附近的，看看能否更新出短的路径。
3. 重复直到所有顶点都被加入访问过的集合中。

注意：无法处理负权值，但有环不影响。

==DAG：有向无环图==

拓扑排序：

AOV网的拓扑排序：

1. 每个结点只出现一次
2. 若A在B之前，说明没有从B到A的路径。

步骤：

1. 选择一个无前驱的结点然后输出
2. 删除顶点和它的所有边，
3. 重复，直到网为空或没有入度为0的结点（证明有环）

邻接矩阵时复杂度：O（V方）

邻接表时复杂度：O（V+E）

拓扑序列唯一也不能唯一确定一个图。

关键路径是从源点到汇点路径长度最长的路径。

## 查找

### 基本概念

1. 查找：就是寻找满足某种条件的元素的过程。
2. 查找表：用于查找的数据集合。
3. 静态查找表：只查找是否在表中，或访问某种属性。
4. 动态：静态+删除+插入。
5. 关键字：用于唯一标识元素的某个数据项的值。
6. 平均查找长度：一次的查找长度是比较关键字的次数。平均查找长度是它的平均值。

### 顺序查找

1. 线性表

   设置哨兵，从后往前查找。

   哨兵的作用是让循环不用判断是否会越界。

2. 有序表

   查找成功的ASL和直接查找一样。

   查找失败时ASL会小一些。

   ![image-20231228155800008](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228155800008.png)

### 折半查找

仅适用于有序的表

查找时，mid=(low+high)/2向下取整。

如果mid查找成功，就成功了。

没成功的话，更新为：low=mid+1或者high=mid-1

循环的条件为low<=high。

折半查找的过程可以用判定树来表示，判定树是平衡二叉树。

依据此可以来算ASL。直接画图分析。

查找n个元素时，树高$log_2(n+1)$向上取整.

![image-20231228160417903](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228160417903.png)

折半查找要求有序顺序表。

### 分块

又叫索引查找。

块间有序，块内无序。

索引表记录的关键字码是块内最大值以及对应的块开始位置。

![image-20231228161508030](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228161508030.png)

注意这是全部顺序查找的情况。

 

判断一个树是不是二分查找的判定树，可以用二叉排序树中序序列是个有序序列来判断。把值按找中序依次填入，如果满足二叉排序树就对了。

### 树型查找

#### 二叉排序树（BST）

构造二叉排序树是为了查找、插入和删除而不是排序。

定义：
左子树所有点小于根小于右子树所有点，递归定义。

中序下是递增的。

查找：

从根节点开始沿着某个分支逐层向下比。

根据大于或者小于依次向下比。

插入：

通过比较到达一个叶结点，然后把自己放上去。

删除：

1. 叶结点：直接删
2. 只有左/右子树：直接让它的子树接到原本他的位置。
3. 左右都有：让z的直接后继（或者前驱）代替z，然后删去之。

查找效率：取决于树的高度，如果是平衡二叉树，则为log2n，最坏的话是n。

### 散列表

概念：

​	散列函数：把查找表中的关键字映射成对应的地址。Hash(key)=Addr

​	如果出现把多个不同关键字映射在同一个位置，则称为冲突。把发生冲突的关键词叫做同义词。

​	冲突总是不可避免的。

​	散列表：根据关键字而直接进行访问的数据结构。建立了关键字和存储地址的直接映射关系。

​	理想情况下的时间复杂度是O（1）

注意：

1. 散列函数定义域包括所有要存储的关键字，而值域大小要依赖于散列表的大小或地址范围。
2. 散列函数计算出来的地址尽量等概率均匀分布，来减少冲突。
3. 尽量简单，提高速度。

常用的方法：

1. 直接定址

   取关键字的某个线性函数值为散列地址。

   h（key）=key或h（key）-a*key+b

   不会产生冲突，但是有可能会浪费空间。

2. 除留余数法

   假设散列表长m，取不大于m但接近或等于m的质数p，key%p。关键是选择一个好的p，尽量减少冲突。

3. 数字分析法

   假设是r进制数，r各个数码在不同位置出现的频率可能不同，找那种分布比较均匀的位置。

4. 平方取中法。

   取关键字平方后中间的几位。具体选择要根据实际。

   适用于关键字每位取值不够均匀或均小于散列地址所需要的位数。

#### 冲突处理

1. 开放定址法

   意思是说可存放新表项的空闲地址可以向同义词开放，也向非同义词。

   h=（h（key）+d）%m。 m是散列表的长。

   1. 线性探测：d=1，2，3，。。。 可能会导致聚集现象。
   2. 平方探测：d=0，1，-1，4，-4，。。。这种情况下，散列表长度m必须是一个可以表示成4k+3的素数。
   3. 双散列法：d=hash2（key）。冲突时会再用一个函数哈希一下。h=（h（key）+i*hash2（key））%m
   4. 伪随机数

2. 拉链儿

   每个位置都存成一个线性链表。

#### 性能分析

查找过程：

初始化之后

1. 检测addr是否有记录，如果没有，返回查找失败。如果有记录，比较是否为key，如果是，返回查找成功。
2. 如果不成功，用给定的冲突处理方法，计算下一个散列地址，并把addr设置为此地址，回到步骤1

散列表性能因素：

1. 散列函数
2. 冲突处理方法
3. 装填因子

![image-20231228172247568](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228172247568.png)

## 排序

### 基本概念

稳定与不稳定

大多数内排序只适合于顺序存储的线性表。

内排序是指排序时元素全在内存里。

### 插入

#### 直接插入

前面有序，后面没序。逐步排序然后加进去。

在基本有序的情况下，比较高效。

平均复杂度n方

稳定。

#### 折半插入

在顺序表时。

比较时用二分法来找要插的位置。

仅减少了比较的次数，复杂度还是n方。

#### 希尔排序

将L分隔，每隔d位取一个值，构成一个新的序列。

然后让每个新序列都有序。

d减小，再次重复上述操作

直到d为1.

性能：不确定，最坏n方，平时n^1.3左右

### 交换排序

#### 冒泡

从后往前两两比较。逆序则交换。

每一次可以让以一个元素归位。

稳定的.

最多n-1次就全跑完了.

如果结束某一趟时没发生交换,说明已经排好了,可以直接退出.

性能:![image-20231228174308916](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228174308916.png)

#### 快排

基于分治的思路.

去一个pivot元素作为枢轴(通常取第一个元素).

通过排序,让左边全小于它,右边全大于他.

它的位置便确定了.这称为一次划分.

然后对左右递归进行操作.

划分能够影响性能.

最好是每次都把元素分为相等的两串.

性能:

![image-20231228174745066](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228174745066.png)

快排过程不产生有序序列,但能使得元素在所需要在的位置上.

默认升序排.

### 选择排序

#### 简单选择排序

就是每次找到要在需要在的位置上的值,然后交换.

每趟排好1个.n-1次结束.

![image-20231228175317586](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228175317586.png)

#### 堆排序

堆得满足根大于左右子树,递归定义.

堆排序思路:

先将所有元素建成一个堆.

然后依次输出堆顶,把最后一个元素放到堆顶,调整为一个新的堆.

调整过程就是依次向下筛选调整.

调整时间和树高h有关.在建立含有n个元素的堆时,总关键字比较次数不多于4n.复杂度为n.所以可以在线性时间内将无序数组简历为一个堆.

同时,堆也支持插入,将新元素放在堆底,然后依次向上调整.

![image-20231228175902224](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228175902224.png)

#### 归并与基数排序

#### 归并排序

"归并"是指将两个或以上的有序表合并成一个新的有序表的过程.

假定有n个数据,每次可以通过两两归并得到n/2向上取整的有序表.

然后依次两两归并重复.直到得到一个长度为n的有序表.称为二路归并.

归并的形式是基于分治的.

![image-20231228180424303](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228180424303.png)

#### 基数排序

假设每个关键字由d元组构成,满足每个位都小于基数且大于0,可以用基数排序.

可以高位优先也可以低位优先.

![image-20231228180619957](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228180619957.png)

![image-20231228180657062](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228180657062.png)

==D,C==

二路归并的操作功能是将两个有序表合并为一个新的有序表.

#### 内排序总结

![image-20231228181018095](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228181018095.png)

![image-20231228181122911](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228181122911.png)

![image-20231228181140932](C:\Users\Baijy\AppData\Roaming\Typora\typora-user-images\image-20231228181140932.png)

