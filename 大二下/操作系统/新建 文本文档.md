# 内存

1. 内部碎片和外部碎片
2. 内存管理的几类需求
3. 常见的内存管理技术和优点缺点
4. 动态分区三种放置算法。最佳、下次、首次。最佳性能最差外部碎片最多，首次性能最好。
5. Unix内核使用了改进的伙伴系统来做内存分配
6. 逻辑地址、相对地址、物理地址的区分
7. 地址转换依赖于硬件机制，典型方法是基址寄存器+界限寄存器
8. 页表给出进程每页对应的页框位置。操作系统为当前内存中未被占用、可供使用的所有页框维护一个空闲页框列表。  
9. 分页对程序员来说是透明的，而分段通常是可见的。采用大小不等的段的另一个结果是，逻辑地址和物理地址间不再是简单的对应关系。  
10. 分段模式下，每个进程都有一个段表 ，系统也会维护一个内存中的空闲块列表。段表项必须给出相应段在内存中的起始地址，还必须指明段的长度，以确保不会使用无效地址。
11. 页表和段表的区别：页表是一个一维数组，每个表项对应一个页框，段表是一个二维数组，每个表项对应一个段。
## 虚拟内存
1. 进程执行的任何时候都在内存的部分称为进程的常驻集（resident set）。
2. 虚存两个效果：在内存中保留多个进程。进程可以比内存的全部空间还大。
3. 系统抖动(thrashing)：处理器的大部分时间都用于交换块而非执行指令。
4. 要使虚存比较实用并且有效，需要两方面的因素。首先，必须有对所采用分页或分段方案的硬件支持；其次，操作系统必须有管理页或段在内存和辅助存储器 (简称辅存) 之间移动的软件。
5. 页表项、段表项都应该有控制位，如P、M。
6. 通常页号域大于帧号域。虚拟地址空间较大，并不意味着每个地址都必须映射到物理内存。未使用的地址空间只是没有分配物理内存或没有映射的部分。
7. 为克服这防止页表所需空间过大的问题，大多数虚拟内存方案都在虚存而非实存中保存页表。这意味着页表和其他页一样都服从分页管理。
8. 多级页表中，寄存器中的页表基址寄存器指向一级页表。
9. 一次内存访问可能产生两次缺页中断：第一次读取所需的页表部分，第二次读取进程页。
10. 两种读取策略。
11. 