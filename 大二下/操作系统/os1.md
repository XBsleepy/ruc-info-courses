# 1

## （1）

两类进程，分别是顾客和职员。

顾客：取号，等待，处理业务。

职员：叫号，服务，叫号...

## （2）

需要2个信号量，一个用来标记空闲窗口数量，初始值为窗口数量n;一个标记目前排队的顾客数，初始值为0.

## （3）

```c++
int window=n//窗口数量。
int waiting=0//排队的客户数。
staff(){
	P(waiting);
    serve();//提供服务。
    v(window);
}
customer(){
    V(waiting);
    P(window);
    change();//换外币。
    V(window);
}
```

# 2

证明：

考虑极端情况：进程需要的R数量为m+n-1。

显然，如果此情况下不会出现死锁，则需要资源数量减少时更不会出现死锁。

此情况下，由于任意进程至少需要1个，则还有m-1个需求供n个进程分配。

无论如何进行分配，在任意时刻：

1. 如果进程的需求量为1个，那么在分配之后该资源会得到释放，不满足死锁的持有并请求条件。故在考虑死锁时不必考虑此类进程。
2. 对于需求量大于1个的进程，它们还可分配m-1个资源，若要形成死锁，则必须满足循环等待。而最极端条件便是任意进程占有所需数量-1个资源，在此情况下，最多分配m-1个资源，至少有1个空闲资源可以分配，那么它会打破当前循环等待的条件。

由此，死锁条件一直无法满足，则不会产生死锁。

# 3

## （1）

3<8，属于直接索引，由于从0开始编号，所以对应磁盘块号2。

## （2）

10>8，属于间接索引。10-8=2，对应间接索引第一个磁盘块的第二个磁盘，也就是8号地址项确定的1号地址对应的值。

## （3）

1. x<=8,直接索引，磁盘块号为x-1.
2. 8<x<=8+256,对应8号地址项确定的第x-8-1个地址指向的磁盘块。
3. 8+256<x,对应二级索引，一次索引偏移量为(x-8-256-1)/256向下取整。二次索引的偏移量为(x-8-256-1)%256.由此可以确定磁盘块号。